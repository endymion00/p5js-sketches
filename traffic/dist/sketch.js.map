{"version":3,"file":"sketch.js","sources":["../../../../node_modules/p5ex/lib/p5ex.mjs","../src/functions.ts","../src/main.ts"],"sourcesContent":["/**\n* An extension of p5.js.\n* Including module: no-more-for-loops (Copyright 2018 FAL, licensed under MIT).\n* GitHub repository: {@link https://github.com/fal-works/p5ex}\n* @module p5ex\n* @copyright 2018 FAL\n* @author FAL <falworks.contact@gmail.com>\n* @license MIT\n* @version 0.5.6\n*/\n\n/**\n * Spatial region.\n */\nclass Region {\n}\n/**\n * Rectangle-shaped spatial region.\n */\nclass RectangleRegion extends Region {\n    get width() { return this.rightPositionX - this.leftPositionX; }\n    get height() { return this.bottomPositionY - this.topPositionY; }\n    get area() { return this.width * this.height; }\n    constructor(x1, y1, x2, y2, margin = 0) {\n        super();\n        this.leftPositionX = x1 - margin;\n        this.topPositionY = y1 - margin;\n        this.rightPositionX = x2 + margin;\n        this.bottomPositionY = y2 + margin;\n    }\n    contains(position, margin = 0) {\n        return (position.x >= this.leftPositionX - margin && position.x <= this.rightPositionX + margin &&\n            position.y >= this.topPositionY - margin && position.y <= this.bottomPositionY + margin);\n    }\n    constrain(position, margin = 0) {\n        if (position.x < this.leftPositionX - margin)\n            position.x = this.leftPositionX - margin;\n        else if (position.x > this.rightPositionX + margin)\n            position.x = this.rightPositionX + margin;\n        if (position.y < this.topPositionY - margin)\n            position.y = this.topPositionY - margin;\n        else if (position.y > this.bottomPositionY + margin)\n            position.y = this.bottomPositionY + margin;\n    }\n}\n// default region -> add\n\n/**\n * (To be filled)\n * @hideConstructor\n */\nclass ScalableCanvas {\n    constructor(p5Instance, parameter, node, rendererType) {\n        this.p = p5Instance;\n        this.canvasElement = p5Instance.createCanvas(parameter.scaledWidth, parameter.scaledHeight, rendererType);\n        if (this.canvasElement && 'parent' in this.canvasElement) {\n            this.canvasElement.parent(node);\n        }\n        this.region = new RectangleRegion(0, 0, 0, 0);\n        this.nonScaledShortSideLength = parameter.nonScaledShortSideLength;\n        this.updateSize();\n    }\n\n    /**\n     * (To be filled)\n     */\n    get scaleFactor() {\n        return this._scaleFactor;\n    }\n    /**\n     * (To be filled)\n     */\n    get nonScaledWidth() {\n        return this._nonScaledWidth;\n    }\n    /**\n     * (To be filled)\n     */\n    get nonScaledHeight() {\n        return this._nonScaledHeight;\n    }\n    /**\n     * (To be filled)\n     */\n    get aspectRatio() {\n        return this._aspectRatio;\n    }\n    /**\n     * (To be filled)\n     * @param parameter\n     */\n    resize(parameter) {\n        this.p.resizeCanvas(parameter.scaledWidth, parameter.scaledHeight);\n        this.nonScaledShortSideLength = parameter.nonScaledShortSideLength;\n        this.updateSize();\n    }\n    /**\n     * (To be filled)\n     */\n    updateSize() {\n        const p = this.p;\n        this._scaleFactor = Math.min(p.width, p.height) / this.nonScaledShortSideLength;\n        this._inversedScaleFactor = 1 / this._scaleFactor;\n        this._nonScaledWidth = p.width / this._scaleFactor;\n        this._nonScaledHeight = p.height / this._scaleFactor;\n        this._aspectRatio = p.width / p.height;\n        this.region.rightPositionX = this._nonScaledWidth;\n        this.region.bottomPositionY = this._nonScaledHeight;\n    }\n    /**\n     * Runs scale() of the current p5 instance for fitting the sketch to the current canvas.\n     * Should be called every frame before drawing objects on the canvas.\n     */\n    scale() {\n        this.p.scale(this._scaleFactor);\n    }\n    /**\n     * Runs scale() with the inversed scale factor.\n     */\n    cancelScale() {\n        this.p.scale(this._inversedScaleFactor);\n    }\n    /**\n     * Converts a length value on the scaled canvas to the non-scaled one.\n     * Typically used for interpreting mouseX and mouseY.\n     * @param {number} scaledLength - scaled length value\n     */\n    getNonScaledValueOf(scaledLength) {\n        return scaledLength / this._scaleFactor;\n    }\n}\nScalableCanvas.DUMMY_PARAMETERS = {\n    scaledWidth: 100,\n    scaledHeight: 100,\n    nonScaledShortSideLength: 100,\n};\n\n/**\n * (To be filled)\n * (This is not implemented as an enum because it is not supported by rollup)\n */\nconst ScalableCanvasTypes = {\n    SQUARE640x640: 'SQUARE640x640',\n    RECT640x480: 'RECT640x480',\n    FULL: 'FULL',\n    CUSTOM: 'CUSTOM',\n};\n\nclass NormalColorUnit {\n    constructor(p, p5Color) {\n        this.p = p;\n        this.p5Color = p5Color;\n    }\n    stroke() {\n        this.p.currentRenderer.stroke(this.p5Color);\n    }\n    fill() {\n        this.p.currentRenderer.fill(this.p5Color);\n    }\n}\nclass NoColorUnit {\n    constructor(p) {\n        this.p = p;\n    }\n    stroke() {\n        this.p.currentRenderer.noStroke();\n    }\n    fill() {\n        this.p.currentRenderer.noFill();\n    }\n}\nclass UndefinedColorUnit {\n    stroke() {\n    }\n    fill() {\n    }\n}\nclass AlphaColorUnit {\n    constructor(p, c, alphaResolution = 256) {\n        this.p = p;\n        const array = [];\n        for (let alphaFactor = 0; alphaFactor < alphaResolution; alphaFactor += 1) {\n            array.push(p.color(p.red(c), p.green(c), p.blue(c), p.alpha(c) * alphaFactor / (alphaResolution - 1)));\n        }\n        this.colorArray = array;\n        this.maxIndex = alphaResolution - 1;\n    }\n    stroke(alphaValue) {\n        this.p.currentRenderer.stroke(this.getColor(alphaValue));\n    }\n    fill(alphaValue) {\n        this.p.currentRenderer.fill(this.getColor(alphaValue));\n    }\n    getColor(alphaValue) {\n        return this.colorArray[alphaValue ? Math.floor(this.p.map(alphaValue, 0, 255, 0, this.maxIndex)) : this.maxIndex];\n    }\n}\nfunction colorUnit(p, p5Color, alphaEnabled, alphaResolution) {\n    if (!p || p5Color === undefined)\n        return new UndefinedColorUnit();\n    if (p5Color === null)\n        return new NoColorUnit(p);\n    if (alphaEnabled)\n        return new AlphaColorUnit(p, p5Color, alphaResolution);\n    return new NormalColorUnit(p, p5Color);\n}\n/**\n * Composition of two p5.Color instances. One for stroke(), one for fill().\n */\nclass ShapeColor {\n    /**\n     *\n     * @param p - p5ex instance.\n     * @param {p5.Color | null | undefined} strokeColor - Color for stroke(). Null means noStroke().\n     * @param {p5.Color | null | undefined} fillColor - Color for fill(). Null means noFill().\n     * @param {boolean} [alphaEnabled]\n     * @param {number} [alphaResolution]\n     */\n    constructor(p, strokeColor, fillColor, alphaEnabled, alphaResolution) {\n        this.strokeColor = colorUnit(p, strokeColor, alphaEnabled, alphaResolution);\n        this.fillColor = colorUnit(p, fillColor, alphaEnabled, alphaResolution);\n    }\n    /**\n     * Applies colors to the current p5 renderer.\n     * @param {number} alphaValue - Alpha channel value (0 - 255)\n     */\n    applyColor(alphaValue) {\n        this.strokeColor.stroke(alphaValue);\n        this.fillColor.fill(alphaValue);\n    }\n}\n/**\n * Undefined object of p5ex.ShapeColor.\n * @static\n */\nShapeColor.UNDEFINED = new ShapeColor(undefined, undefined, undefined);\n\n/**\n * An empty function.\n */\nconst EMPTY_FUNCTION = () => { };\n/**\n * 1.5 * PI\n */\nconst ONE_AND_HALF_PI = 1.5 * Math.PI;\n\nconst dummyP5 = new p5((p) => {\n    p.setup = () => {\n        p.noCanvas();\n    };\n});\n\n/**\n * Calculates the squared value of the Euclidean distance between\n * two points (considering a point as a vector object).\n */\nfunction distSq(v1, v2) {\n    return Math.pow(v2.x - v1.x, 2) + Math.pow(v2.y - v1.y, 2) + Math.pow(v2.z - v1.z, 2);\n}\n/**\n * Multiplies the given matrix and array.\n * The number of matrix columns and the array length must be identical.\n * @param {number[][]} matrix - Any matrix.\n * @param {number[]} array - Any one-dimensional array of numbers.\n * @param {number[]} [target] - Target array for receiving the result.\n * @returns Product of the given values as an array.\n */\nfunction multiplyMatrixAndArray(matrix, array, target) {\n    const matrixRowCount = matrix.length;\n    const matrixColumnCount = matrix[0].length;\n\n    const resultArray = target || new Array(matrixRowCount);\n\n    for (let row = 0; row < matrixRowCount; row += 1) {\n        resultArray[row] = 0;\n        for (let col = 0; col < matrixColumnCount; col += 1) {\n            resultArray[row] += matrix[row][col] * array[col];\n        }\n    }\n    return resultArray;\n}\nconst TWO_PI = 2 * Math.PI;\n/**\n * Calculates the difference between two angles in range of -PI to PI.\n * @param angleA - the angle to subtract from\n * @param angleB - the angle to subtract\n */\nfunction angleDifference(angleA, angleB) {\n    let diff = (angleA - angleB) % TWO_PI;\n    if (diff < -Math.PI)\n        diff += TWO_PI;\n    else if (diff > Math.PI)\n        diff -= TWO_PI;\n    return diff;\n}\n/**\n * Calculates the direction angle from one vector to another.\n * @param referencePosition\n * @param targetPosition\n */\nfunction getDirectionAngle(referencePosition, targetPosition) {\n    return Math.atan2(targetPosition.y - referencePosition.y, targetPosition.x - referencePosition.x);\n}\n// Temporal vectors for calculation use in getClosestPositionOnLineSegment()\nconst tmpVectorAP = dummyP5.createVector();\nconst tmpVectorAB = dummyP5.createVector();\n/**\n * Just lerp.\n * @param startValue - The start value.\n * @param endValue - The end value.\n * @param ratio - The ratio between 0 and 1.\n */\nfunction lerp(startValue, endValue, ratio) {\n    return startValue + ratio * (endValue - startValue);\n}\n\n/**\n * Returns random value from the min number up to (but not including) the max number.\n */\nfunction randomBetween(min, max) {\n    return min + Math.random() * (max - min);\n}\n/**\n * Returns random integer from 0 up to (but not including) the max number.\n */\nfunction randomInt(maxInt) {\n    return Math.floor(Math.random() * maxInt);\n}\n/**\n * Returns random integer from the min number up to (but not including) the max number.\n */\nfunction randomIntBetween(minInt, maxInt) {\n    return minInt + randomInt(maxInt - minInt);\n}\n/**\n * Returns one of array elements randomly.\n * @param array\n */\nfunction getRandom(array) {\n    return array[randomInt(array.length)];\n}\n/**\n * Returns n or -n randomly. (n = provided number)\n * @param {number} n - any number\n */\nfunction randomSign(n) {\n    if (Math.random() < 0.5)\n        return n;\n    return -n;\n}\n/**\n * Returns and removes one array element randomly.\n * @param array\n */\nfunction popRandom(array) {\n    return array.splice(randomInt(array.length), 1)[0];\n}\n\n/**\n * Container class of number.\n */\nclass NumberContainer {\n    /**\n     * @constructor\n     * @param {number} value\n     */\n    constructor(value = 0) {\n        this.value = value;\n    }\n    valueOf() {\n        return this.value;\n    }\n}\n/**\n * Null object of NumberContainer.\n * @static\n */\nNumberContainer.NULL = new NumberContainer();\n\n/**\n * (To be filled)\n */\nclass WeightedRandomSelector {\n    constructor() {\n        this.candidateList = [];\n        this.candidateCount = 0;\n        this.totalProbabiligyWeight = 0;\n    }\n    /**\n     * Adds one element with provided weight of probability.\n     * @param element\n     * @param probabilityWeight\n     * @chainable\n     */\n    push(element, probabilityWeight) {\n        this.candidateList.push({\n            element,\n            threshold: this.totalProbabiligyWeight + probabilityWeight,\n        });\n        this.candidateCount += 1;\n        this.totalProbabiligyWeight += probabilityWeight;\n        return this;\n    }\n    /**\n     * Clears all elements.\n     * @chainable\n     */\n    clear() {\n        this.candidateList.length = 0;\n        this.candidateCount = 0;\n        this.totalProbabiligyWeight = 0;\n        return this;\n    }\n    /**\n     * Returns one element randomly.\n     * The probability for each element is:\n     * (probability weight of the element) / (total probability weight)\n     */\n    get() {\n        const rnd = Math.random() * this.totalProbabiligyWeight;\n        for (let i = 0; i < this.candidateCount; i += 1) {\n            if (rnd < this.candidateList[i].threshold)\n                return this.candidateList[i].element;\n        }\n        return this.candidateList[this.candidateCount - 1].element; // unreachable\n    }\n}\n\n/**\n * Linear easing function.\n * @param ratio\n */\nfunction easeLinear(ratio) {\n    return ratio;\n}\n/**\n * easeOutQuad.\n * @param ratio\n */\nfunction easeOutQuad(ratio) {\n    return -Math.pow(ratio - 1, 2) + 1;\n}\n/**\n * easeOutCubic.\n * @param ratio\n */\nfunction easeOutCubic(ratio) {\n    return Math.pow(ratio - 1, 3) + 1;\n}\n/**\n * easeOutQuart.\n * @param ratio\n */\nfunction easeOutQuart(ratio) {\n    return -Math.pow(ratio - 1, 4) + 1;\n}\nconst EASE_OUT_BACK_DEFAULT_COEFFICIENT = 1.70158;\n/**\n * easeOutBack.\n * @param ratio\n */\nfunction easeOutBack(ratio) {\n    const r = ratio - 1;\n    return ((EASE_OUT_BACK_DEFAULT_COEFFICIENT + 1) * Math.pow(r, 3)\n        + EASE_OUT_BACK_DEFAULT_COEFFICIENT * Math.pow(r, 2) + 1);\n}\n/**\n * Returns an easeOut function.\n * @param exponent - Integer from 1 to 4.\n */\nfunction getEasingFunction(exponent) {\n    switch (Math.floor(exponent)) {\n        default:\n        case 1:\n            return easeLinear;\n        case 2:\n            return easeOutQuad;\n        case 3:\n            return easeOutCubic;\n        case 4:\n            return easeOutQuart;\n    }\n}\n\n/**\n * (To be filled)\n */\nclass RandomShapeColor {\n    constructor() {\n        this.candidateArray = [];\n    }\n    /**\n     * (To be filled)\n     * @param createShapeColor - Any function which returns a p5ex.ShapeColor instance.\n     * @param {number} candidateCount - Number of color candidates to push.\n     */\n    pushCandidateFromFunction(createShapeColor, candidateCount) {\n        for (let i = 0; i < candidateCount; i += 1) {\n            this.candidateArray.push(createShapeColor());\n        }\n        return this;\n    }\n    /**\n     * (To be filled)\n     * @param {p5.Color} shapeColor - Any p5.Color instance.\n     * @param {number} candidateCount - Number of color candidates to push.\n     */\n    pushCandidate(shapeColor, candidateCount = 1) {\n        for (let i = 0; i < candidateCount; i += 1) {\n            this.candidateArray.push(shapeColor);\n        }\n        return this;\n    }\n    /**\n     * Clears all color candidates.\n     */\n    clear() {\n        this.candidateArray.length = 0;\n        return this;\n    }\n    /**\n     * Returns one of color candidates randomly.\n     */\n    get() {\n        return getRandom(this.candidateArray);\n    }\n}\n\nfunction createCielabToXyzFunc() {\n    const delta = 6 / 29;\n    const constantA = 16 / 116;\n    const constantB = 3 * delta * delta;\n    return (value) => {\n        if (value > delta)\n            return value * value * value;\n        return (value - constantA) * constantB;\n    };\n}\nconst cielabToXyzFunc = createCielabToXyzFunc();\n/**\n * Converts color values from CIELAB (D65) to XYZ.\n * @param {number[]} cielabValue - Value array of L*, a*, b* (D65).\n * @param {Illuminant} illuminant - Instance of Illuminant.\n * @param {number[]} [target] - Target array for receiving the result.\n * @returns {number[]} XYZ value array.\n */\nfunction cielabValueToXyzValue(cielabValue, illuminant, target) {\n    const yFactor = (cielabValue[0] + 16.0) / 116.0;\n    const xFactor = yFactor + cielabValue[1] / 500.0;\n    const zFactor = yFactor - cielabValue[2] / 200.0;\n    if (target) {\n        target[0] = illuminant.tristimulusValues[0] * cielabToXyzFunc(xFactor);\n        target[1] = illuminant.tristimulusValues[1] * cielabToXyzFunc(yFactor);\n        target[2] = illuminant.tristimulusValues[2] * cielabToXyzFunc(zFactor);\n        return target;\n    }\n    return [\n        illuminant.tristimulusValues[0] * cielabToXyzFunc(xFactor),\n        illuminant.tristimulusValues[1] * cielabToXyzFunc(yFactor),\n        illuminant.tristimulusValues[2] * cielabToXyzFunc(zFactor),\n    ];\n}\n\n/**\n * Matrix for conversion color values from XYZ to linear RGB.\n * Values from \"7. Conversion from XYZ (D65) to linear sRGB values\" in\n * http://www.color.org/chardata/rgb/sRGB.pdf (April 2015)\n * @constant {number[][]} xyzToLinearRgbConversionMatrix\n * @ignore\n */\nconst xyzToLinearRgbConversionMatrix = [\n    [3.2406255, -1.537208, -0.4986286],\n    [-0.9689307, 1.8757561, 0.0415175],\n    [0.0557101, -0.2040211, 1.0569959],\n];\n/**\n * CIE standard illuminant.\n */\nclass Illuminant {\n    constructor(name, tristimulusValues) {\n        this.name = name;\n        this.tristimulusValues = tristimulusValues;\n    }\n}\n\n/**\n * Map of illuminants.\n */\nconst Illuminants = {\n    D50: new Illuminant('D50', [0.9642, 1.0000, 0.8251]),\n    D55: new Illuminant('D55', [0.9568, 1.0000, 0.9214]),\n    D65: new Illuminant('D65', [0.95047, 1.00000, 1.08883]),\n    E: new Illuminant('E', [1, 1, 1]),\n};\n\n/**\n * Applies display gamma correction to the given number.\n * @param value - any number in a linear color space (0 - 1).\n * @ignore\n */\nfunction degamma(value) {\n    if (value <= 0.0031308)\n        return 12.92 * value;\n    return 1.055 * Math.pow(value, 1.0 / 2.4) - 0.055;\n}\n/**\n * Returns the difference of two colors. The alpha values of the original colors will be ignored.\n * @param {p5.Color} c1 - The color to subtract from\n * @param {p5.Color} c2 - The color to subtract\n * @param {number} [alphaValue] - Alpha value of the result color\n */\nfunction subtractColor(c1, c2, alphaValue) {\n    return dummyP5.color(dummyP5.red(c1) - dummyP5.red(c2), dummyP5.green(c1) - dummyP5.green(c2), dummyP5.blue(c1) - dummyP5.blue(c2), alphaValue);\n}\n/**\n * Creates a new p5.Color instance in HSB color mode and\n * immediately reset the color mode to default.\n * @param {number} h - Hue (0 - 360)\n * @param {number} s - Saturation (0 - 100)\n * @param {number} b - Brightness (0 - 100)\n * @param {number} [a] - Alpha (0 - 255)\n */\nfunction hsbColor(h, s, b, a) {\n    dummyP5.colorMode(dummyP5.HSB, 360, 100, 100, 255);\n    const c = dummyP5.color(h, s, b);\n    dummyP5.colorMode(dummyP5.RGB, 1, 1, 1, 255);\n    const gammaCorrectedColor = dummyP5.color(degamma(dummyP5.red(c)), degamma(dummyP5.green(c)), degamma(dummyP5.blue(c)), a);\n    dummyP5.colorMode(dummyP5.RGB, 255, 255, 255, 255);\n    return gammaCorrectedColor;\n}\n\nlet currentIlluminant = Illuminants.D50;\n/**\n * Sets the current illuminant. (e.g. D50, D65 etc.)\n * @param illuminant - Any Illuminant.\n * @example setIlluminant(Illuminants.D65);\n */\nfunction setIlluminant(illuminant) {\n    currentIlluminant = illuminant;\n}\nconst temporalArray1 = [0, 0, 0];\nconst temporalArray2 = [0, 0, 0];\nconst temporalArray3 = [0, 0, 0];\nconst temporalArray4 = [0, 0, 0];\nfunction assignArray(array, v0, v1, v2) {\n    array[0] = v0;\n    array[1] = v1;\n    array[2] = v2;\n    return array;\n}\n/**\n * Clips the given linear RGB factor to the valid range (0 - 1)\n * and converts it to an sRGB value (0 - 255).\n * @param factor - Factor of either red, green or blue in the linear RGB color space.\n * @returns sRGB value.\n * @ignore\n */\nfunction linearRgbFactorToSrgbValue(factor) {\n    return degamma(Math.min(Math.max(factor, 0), 1)) * 255;\n}\n/**\n * Converts CIELAB values to an array of RGB values (0 - 255).\n * @param {number} lValue - L*: Lightness (0 - 100)\n * @param {number} aValue - a* (0 - ca. 100)\n * @param {number} bValue - b* (0 - ca. 100)\n * @param {number} [alphaValue] - Alhpa value (0 - 255)\n * @returns New Array of sRGB values.\n */\nfunction cielabColor(lValue, aValue, bValue, alphaValue) {\n    const labValue = assignArray(temporalArray1, lValue, aValue, bValue);\n    const xyzValue = cielabValueToXyzValue(labValue, currentIlluminant, temporalArray2);\n    const rgbFactor = multiplyMatrixAndArray(xyzToLinearRgbConversionMatrix, xyzValue, temporalArray3);\n    const srgbValue = assignArray(temporalArray4, linearRgbFactorToSrgbValue(rgbFactor[0]), linearRgbFactorToSrgbValue(rgbFactor[1]), linearRgbFactorToSrgbValue(rgbFactor[2]));\n    return alphaValue ? [\n        srgbValue[0],\n        srgbValue[1],\n        srgbValue[2],\n        alphaValue,\n    ] : [\n        srgbValue[0],\n        srgbValue[1],\n        srgbValue[2],\n    ];\n}\n/**\n * Converts CIELCh values to an array of RGB values (0 - 255).\n * @param {number} lValue - L*: Lightness (0 - 100)\n * @param {number} cValue - C*: Chroma (0 - ca. 100)\n * @param {number} hValue - h*: Hue (0 - 2PI)\n * @param {number} [alphaValue] - Alhpa value (0 - 255)\n */\nfunction cielchColor(lValue, cValue, hValue, alphaValue) {\n    return cielabColor(lValue, cValue * Math.cos(hValue), cValue * Math.sin(hValue), alphaValue);\n}\n\n/**\n * (To be filled)\n */\nclass ScreenEffect {\n    constructor(p) {\n        this.p = p;\n    }\n}\n/**\n * (To be filled)\n */\nclass ScreenShake extends ScreenEffect {\n    constructor(p, dampingRatio = 0.95) {\n        super(p);\n        this.dampingRatio = dampingRatio;\n        this.amplitude = 0;\n        this.offsetX = 0;\n        this.offsetY = 0;\n    }\n    apply() {\n        if (this.amplitude === 0)\n            return;\n        this.offsetX = Math.random() * this.amplitude;\n        this.offsetY = Math.random() * this.amplitude;\n        this.p.currentRenderer.translate(this.offsetX, this.offsetY);\n        this.amplitude = this.amplitude * this.dampingRatio;\n        if (this.amplitude < 1)\n            this.amplitude = 0;\n    }\n    set(amplitude) {\n        this.amplitude = Math.max(this.amplitude, amplitude);\n    }\n    reset() {\n        this.amplitude = 0;\n    }\n    cancel() {\n        this.p.currentRenderer.translate(-this.offsetX, -this.offsetY);\n    }\n}\n/**\n * (To be filled)\n */\nclass ScreenFlash extends ScreenEffect {\n    constructor(p, flashColor = p.color(255)) {\n        super(p);\n        this.alphaValue = 0;\n        this.valueChange = 0;\n        this.flashColor = new ShapeColor(p, null, flashColor, true);\n    }\n    apply() {\n        if (this.alphaValue === 0)\n            return;\n        this.flashColor.applyColor(this.alphaValue);\n        this.p.currentRenderer.rect(0, 0, this.p.scalableCanvas.nonScaledWidth, this.p.scalableCanvas.nonScaledHeight);\n        this.alphaValue -= this.valueChange;\n        if (this.alphaValue < 1)\n            this.alphaValue = 0;\n    }\n    set(initialAlphaValue, durationSeconds) {\n        this.alphaValue = initialAlphaValue;\n        this.valueChange = initialAlphaValue / (durationSeconds * this.p.idealFrameRate);\n    }\n    reset() {\n        this.alphaValue = 0;\n    }\n}\n\n/**\n * (To be filled)\n */\nclass AlphaBackground {\n    /**\n     *\n     * @param p5exInstance\n     * @param backgroundColor\n     * @param drawIntervalFrameCount\n     * @param blendModeString\n     * @param defaultBlendModeString\n     */\n    constructor(p5exInstance, backgroundColor, drawIntervalFrameCount = 1, blendModeString, defaultBlendModeString) {\n        this.p = p5exInstance;\n        this.backgroundColor = backgroundColor;\n        this.drawIntervalFrameCount = drawIntervalFrameCount;\n        this.blendModeString = blendModeString;\n        this.defaultBlendModeString = defaultBlendModeString;\n    }\n    /**\n     * Draws the background.\n     */\n    draw() {\n        if (this.p.frameCount % this.drawIntervalFrameCount !== 0)\n            return;\n        if (this.blendModeString)\n            this.p.blendMode(this.blendModeString);\n        this.p.noStroke();\n        this.p.fill(this.backgroundColor);\n        this.p.rect(0, 0, this.p.width, this.p.height);\n        if (this.defaultBlendModeString)\n            this.p.blendMode(this.defaultBlendModeString);\n    }\n}\n\n/**\n * Returns true if the mouse is within the canvas.\n * @param p - The p5 instance.\n */\nfunction mouseIsInCanvas(p) {\n    if (p.mouseX < 0)\n        return false;\n    if (p.mouseX > p.width)\n        return false;\n    if (p.mouseY < 0)\n        return false;\n    if (p.mouseY > p.height)\n        return false;\n    return true;\n}\n\nfunction loopArrayLimited(array, callback, arrayLength) {\n    let i = 0;\n    while (i < arrayLength) {\n        callback(array[i], i, array);\n        i += 1;\n    }\n}\n/**\n * Executes a provided function once for each array element.\n * @param {Array} array\n * @param {loopArrayCallBack} callback\n */\nfunction loopArray(array, callback) {\n    loopArrayLimited(array, callback, array.length);\n}\nfunction loopArrayBackwardsLimited(array, callback, arrayLength) {\n\n    while (arrayLength--) {\n        callback(array[arrayLength], arrayLength, array);\n    }\n}\n/**\n * Executes a provided function once for each array element in descending order.\n * @param {Array} array\n * @param {loopArrayCallback} callback\n */\nfunction loopArrayBackwards(array, callback) {\n    loopArrayBackwardsLimited(array, callback, array.length);\n}\n/**\n * @callback loopArrayCallBack\n * @param {} currentValue\n * @param {number} [index]\n * @param {Array} [array]\n */\n\nfunction roundRobinLimited(array, callback, arrayLength) {\n    for (let i = 0, len = arrayLength - 1; i < len; i += 1) {\n        for (let k = i + 1; k < arrayLength; k += 1) {\n            callback(array[i], array[k]);\n        }\n    }\n}\n/**\n * Executes a provided function once for each pair within the array.\n * @param {Array} array\n * @param {roundRobinCallBack} callback\n */\nfunction roundRobin(array, callback) {\n    roundRobinLimited(array, callback, array.length);\n}\n/**\n * @callback roundRobinCallBack\n * @param {} element\n * @param {} otherElement\n */\n\nfunction nestedLoopJoinLimited(array, otherArray, callback, arrayLength, otherArrayLength) {\n    for (let i = 0; i < arrayLength; i += 1) {\n        for (let k = 0; k < otherArrayLength; k += 1) {\n            callback(array[i], otherArray[k]);\n        }\n    }\n}\n/**\n * Joins two arrays and executes a provided function once for each joined pair.\n * @param {Array} array\n * @param {Array} otherArray\n * @param {nestedLoopJoinCallBack} callback\n */\nfunction nestedLoopJoin(array, otherArray, callback) {\n    nestedLoopJoinLimited(array, otherArray, callback, array.length, otherArray.length);\n}\n/**\n * @callback nestedLoopJoinCallBack\n * @param {} element\n * @param {} otherElement\n */\n\n/**\n * A class containing an array and several loop methods.\n */\nclass LoopableArray {\n    /**\n     * @param {number} initialCapacity\n     */\n    constructor(initialCapacity = 256) {\n\n        this.array = new Array(initialCapacity);\n        this.length = 0;\n    }\n    /**\n     * Returns a specific element.\n     * It is recommended to check that you are going to specify a valid index number\n     * before calling this method.\n     * @returns The specified element.\n     */\n    get(index) {\n        return this.array[index];\n    }\n    /**\n     * Returns the last element.\n     * It is recommended to check that this array is not empty before calling this method.\n     * @returns The last element.\n     */\n    getLast() {\n        return this.array[this.length - 1];\n    }\n    /**\n     * Adds one element to the end of the array and returns the new length of the array.\n     * @param {} element - The element to add to the end of the array.\n     */\n    push(element) {\n        this.array[this.length] = element;\n        this.length += 1;\n        return this.length;\n    }\n    /**\n     * Adds elements to the end of the array and returns the new length of the array.\n     * @param {Array} array - The elements to add to the end of the array.\n     */\n    pushRawArray(array, arrayLength = array.length) {\n        for (let i = 0; i < arrayLength; i += 1) {\n            this.array[this.length + i] = array[i];\n        }\n        this.length += arrayLength;\n        return this.length;\n    }\n    /**\n     * Adds all elements from another LoopableArray and returns the new length of the array.\n     * @param {LoopableArray} otherLoopableArray\n     */\n    pushAll(otherLoopableArray) {\n        return this.pushRawArray(otherLoopableArray.array, otherLoopableArray.length);\n    }\n    /**\n     * Removes and returns the last element.\n     * It is recommended to check that this array is not empty before calling this method.\n     * @returns The last element.\n     */\n    pop() {\n        this.length -= 1;\n        return this.array[this.length];\n    }\n    /**\n     * Clears the array.\n     */\n    clear() {\n        this.length = 0;\n    }\n    /**\n     * @callback loopArrayCallBack\n     * @param {} currentValue\n     * @param {number} [index]\n     * @param {Array} [array]\n     */\n    /**\n     * Executes a provided function once for each array element.\n     * @param {loopArrayCallBack} callback\n     */\n    loop(callback) {\n        loopArrayLimited(this.array, callback, this.length);\n    }\n    /**\n     * Executes a provided function once for each array element in descending order.\n     * @param {loopArrayCallBack} callback\n     */\n    loopBackwards(callback) {\n        loopArrayBackwardsLimited(this.array, callback, this.length);\n    }\n    /**\n     * @callback elementPairCallBack\n     * @param {} element\n     * @param {} otherElement\n     */\n    /**\n     * Executes a provided function once for each pair within the array.\n     * @param {elementPairCallback} callback\n     */\n    roundRobin(callback) {\n        roundRobinLimited(this.array, callback, this.length);\n    }\n    /**\n     * Joins two arrays and executes a provided function once for each joined pair.\n     * @param {LoopableArray} otherArray\n     * @param {elementPairCallback} callback\n     */\n    nestedLoopJoin(otherArray, callback) {\n        nestedLoopJoinLimited(this.array, otherArray.array, callback, this.length, otherArray.length);\n    }\n}\n\n/**\n * (To be filled)\n */\nclass TwoDimensionalArray extends LoopableArray {\n    /**\n     * (To be filled)\n     * @param {number} xCount\n     * @param {number} yCount\n     * @param fillElement\n     */\n    constructor(xCount, yCount, fillElement) {\n        super(xCount * yCount);\n        this.xCount = xCount;\n        this.yCount = yCount;\n        if (fillElement) {\n            for (let i = 0, len = xCount * yCount; i < len; i += 1) {\n                this.push(fillElement);\n            }\n        }\n    }\n    /**\n     * Returns the specified element.\n     * @param x\n     * @param y\n     */\n    get2D(x, y) {\n        return this.array[x + this.xCount * y];\n    }\n    /**\n     * (To be filled)\n     * @param x\n     * @param y\n     * @param element\n     */\n    set2D(x, y, element) {\n        this.array[x + this.xCount * y] = element;\n    }\n}\n\n/**\n * A Naive implementation of an edge between two objects.\n */\nclass NaiveEdge {\n    /**\n     *\n     * @param nodeA\n     * @param nodeB\n     */\n    constructor(nodeA, nodeB) {\n        this.nodeA = nodeA;\n        this.nodeB = nodeB;\n    }\n    /**\n     * Returns true if the provided node is incident to this edge.\n     * @param node\n     */\n    isIncidentTo(node) {\n        return node === this.nodeA || node === this.nodeB;\n    }\n    /**\n     * Returns the adjacent node of the given node via this edge.\n     * If this edge is not incident to the given node, returns always the end point node.\n     * @param {T} node - any node which is incident to this edge\n     */\n    getAdjacentNode(node) {\n        if (node === this.nodeB)\n            return this.nodeA;\n        return this.nodeB;\n    }\n}\n\n/**\n * (To be filled)\n */\nclass NullCell {\n    getNeighborCell(relativeX, relativeY) {\n        return this;\n    }\n    setNeighborCell(relativeX, relativeY, cell) { }\n}\nconst NULL = new NullCell();\n/**\n * (To be filled)\n */\nclass NaiveCell {\n    /**\n     *\n     * @param neighborRange\n     */\n    constructor(neighborRange = 1) {\n        this.neighborCells = new TwoDimensionalArray(2 * neighborRange + 1, 2 * neighborRange + 1, NULL);\n    }\n    /**\n     * Returns the specified neighbor cell.\n     * @param {number} relativeX\n     * @param {number} relativeY\n     */\n    getNeighborCell(relativeX, relativeY) {\n        const neighborRange = Math.floor(this.neighborCells.xCount / 2);\n        if (relativeX < -neighborRange || relativeX > neighborRange ||\n            relativeY < -neighborRange || relativeY > neighborRange)\n            return NULL;\n        return this.neighborCells.get2D(relativeX + neighborRange, relativeY + neighborRange);\n    }\n    /**\n     * Sets the provided cell as a neighbor of this cell.\n     * @param relativeX\n     * @param relativeY\n     * @param cell\n     */\n    setNeighborCell(relativeX, relativeY, cell) {\n        const neighborRange = Math.floor(this.neighborCells.xCount / 2);\n        this.neighborCells.set2D(relativeX + neighborRange, relativeY + neighborRange, cell);\n    }\n}\n/**\n * (To be filled)\n */\nclass Grid {\n    /**\n     *\n     * @param {number} xCount\n     * @param {number} yCount\n     * @param {number} neighborRange\n     * @param {boolean} loopAtEndOfScreen\n     */\n    constructor(xCount, yCount, neighborRange, loopAtEndOfScreen, cellFactory, nullCell) {\n        this.nullCell = nullCell;\n        this.cell2DArray = new TwoDimensionalArray(xCount, yCount, nullCell);\n        this.cellIndexMap = new Map();\n        for (let yIndex = 0; yIndex < yCount; yIndex += 1) {\n            for (let xIndex = 0; xIndex < xCount; xIndex += 1) {\n                const cell = cellFactory(neighborRange);\n                this.cell2DArray.set2D(xIndex, yIndex, cell);\n                this.cellIndexMap.set(cell, { x: xIndex, y: yIndex });\n            }\n        }\n        this.cell2DArray.loop((cell) => {\n            this.setNeighborCells(cell, neighborRange, loopAtEndOfScreen);\n        });\n    }\n    /**\n     * Returns the specified cell.\n     * @param {number} x - X index.\n     * @param {number} y - Y index.\n     */\n    getCell(x, y) {\n        return this.cell2DArray.get2D(x, y);\n    }\n    /**\n     * Returns the x and y index of the given cell.\n     * @param cell\n     */\n    getCellIndex(cell) {\n        return this.cellIndexMap.get(cell) || { x: -1, y: -1 };\n    }\n    /**\n     * (To be filled)\n     * @param referenceCell\n     * @param {number} relX\n     * @param {number} relY\n     * @param {boolean} loopAtEndOfScreen\n     */\n    getRelativePositionCell(referenceCell, relX, relY, loopAtEndOfScreen) {\n        if (referenceCell === this.nullCell)\n            return referenceCell;\n        if (relX === 0 && relY === 0)\n            return referenceCell;\n        const referenceIndex = this.getCellIndex(referenceCell);\n        const targetIndex = {\n            x: referenceIndex.x + relX,\n            y: referenceIndex.y + relY,\n        };\n        if (loopAtEndOfScreen) {\n            if (targetIndex.x < 0)\n                targetIndex.x += this.cell2DArray.xCount;\n            else if (targetIndex.x >= this.cell2DArray.xCount)\n                targetIndex.x -= this.cell2DArray.xCount;\n            if (targetIndex.y < 0)\n                targetIndex.y += this.cell2DArray.yCount;\n            else if (targetIndex.y >= this.cell2DArray.yCount)\n                targetIndex.y -= this.cell2DArray.yCount;\n        }\n        else {\n            if (targetIndex.x < 0 || targetIndex.x >= this.cell2DArray.xCount ||\n                targetIndex.y < 0 || targetIndex.y >= this.cell2DArray.yCount)\n                return this.nullCell;\n        }\n        return this.cell2DArray.get2D(targetIndex.x, targetIndex.y);\n    }\n    setNeighborCells(referenceCell, neighborRange, loopAtEndOfScreen) {\n        for (let relativeX = -neighborRange; relativeX <= neighborRange; relativeX += 1) {\n            for (let relativeY = -neighborRange; relativeY <= neighborRange; relativeY += 1) {\n                referenceCell.setNeighborCell(relativeX, relativeY, this.getRelativePositionCell(referenceCell, relativeX, relativeY, loopAtEndOfScreen));\n            }\n        }\n    }\n}\n\n/**\n * (To be filled)\n */\nclass DrawableArray extends LoopableArray {\n    static drawFunction(value) {\n        value.draw();\n    }\n    /**\n     * Draws all child elements.\n     */\n    draw() {\n        this.loop(DrawableArray.drawFunction);\n    }\n}\n\n/**\n * (To be filled)\n */\nclass SteppableArray extends LoopableArray {\n    static stepFunction(value) {\n        value.step();\n    }\n    /**\n     * Steps all child elements.\n     */\n    step() {\n        this.loop(SteppableArray.stepFunction);\n    }\n}\n\n/**\n * (To be filled)\n */\nclass SpriteArray extends LoopableArray {\n}\nSpriteArray.prototype.step = SteppableArray.prototype.step;\nSpriteArray.prototype.draw = DrawableArray.prototype.draw;\n\n/**\n * (To be filled)\n */\nclass CleanableArray extends LoopableArray {\n    /**\n     *\n     * @param initialCapacity\n     */\n    constructor(initialCapacity) {\n        super(initialCapacity);\n        this.recentRemovedElements = new LoopableArray(initialCapacity);\n    }\n    /**\n     * Updates the variable 'isToBeRemoved'.\n     * If it has cleanable child elements, calls clean() recursively and\n     * removes the child elements which are to be removed.\n     */\n    clean() {\n        this.recentRemovedElements.clear();\n        let validElementCount = 0;\n        for (let i = 0; i < this.length; i += 1) {\n            this.array[i].clean();\n            if (this.array[i].isToBeRemoved) {\n                this.recentRemovedElements.push(this.array[i]);\n                continue;\n            }\n            this.array[validElementCount] = this.array[i];\n            validElementCount += 1;\n        }\n        this.length = validElementCount;\n    }\n}\n\n/**\n * (To be filled)\n */\nclass CleanableSpriteArray extends CleanableArray {\n}\nCleanableSpriteArray.prototype.draw = SpriteArray.prototype.draw;\nCleanableSpriteArray.prototype.step = SpriteArray.prototype.step;\n\n/**\n * Object pool which calls the provided function for every element when using & recyling.\n * Intended to use with the library deePool, but can also be used with another implementation.\n */\nclass ObjectPool {\n    /**\n     *\n     * @param naivePool - The pool object with use() and recycle(obj) methods.\n     * @param useProcess - The callback function which will be called in use().\n     * @param recycleProcess - The callback function which will be called in recycle().\n     */\n    constructor(naivePool, useProcess, recycleProcess) {\n        this.naivePool = naivePool;\n        this.useProcess = useProcess || ((object) => { });\n        this.recycleProcess = recycleProcess || ((object) => { });\n        this.recycle = (usedObject) => {\n            this.recycleProcess(usedObject);\n            this.naivePool.recycle(usedObject);\n        };\n    }\n    /**\n     * Returns an object which is currently not in use.\n     */\n    use() {\n        const newObject = this.naivePool.use();\n        this.useProcess(newObject);\n        return newObject;\n    }\n    /**\n     * Recycles all elements of the provided array.\n     * @param array\n     */\n    recycleAll(array) {\n        array.loop(this.recycle);\n    }\n}\n/**\n * Array of pooled objects. Recycles every removing object when clean() has been called.\n */\nclass PoolableArray extends CleanableArray {\n    constructor(pool, initialCapacity) {\n        super(initialCapacity);\n        this.pool = pool;\n    }\n    clean() {\n        super.clean();\n        this.recentRemovedElements.loop(this.pool.recycle);\n        this.recentRemovedElements.clear();\n    }\n}\n\n/**\n * (To be filled)\n */\nclass ScaleFactor {\n    /**\n     *\n     * @param p - p5ex instance.\n     * @param { number } [value = 1]\n     */\n    constructor(p, value = 1) {\n        this.p = p;\n        this.internalValue = value;\n        this.internalReciprocalValue = 1 / value;\n    }\n    /**\n     * The numeric value of the scale factor.\n     */\n    get value() {\n        return this.internalValue;\n    }\n    set value(v) {\n        if (v === 0) {\n            this.internalValue = 0.0001;\n            this.internalReciprocalValue = 10000;\n            return;\n        }\n        this.internalValue = v;\n        this.internalReciprocalValue = 1 / v;\n    }\n    /**\n     * The reciprocal value of the scale factor.\n     */\n    get reciprocalValue() {\n        return this.internalReciprocalValue;\n    }\n    /**\n     * Calls scale().\n     */\n    applyScale() {\n        this.p.currentRenderer.scale(this.internalValue);\n    }\n    /**\n     * Calls scale() with the reciprocal value.\n     */\n    cancel() {\n        this.p.currentRenderer.scale(this.internalReciprocalValue);\n    }\n}\n\n/**\n * (To be filled)\n */\nclass DrawerBuilder {\n    /**\n     *\n     * @param p\n     */\n    constructor(p) {\n        /**\n         * Parameter for drawing.\n         */\n        this.drawParam = {};\n        this.p = p;\n    }\n    /**\n     * @param element\n     * @chainable\n     */\n    setElement(element) {\n        this.element = element;\n        return this;\n    }\n    /**\n     * @param positionRef\n     * @chainable\n     */\n    setPositionRef(positionRef) {\n        this.drawParam.positionRef = positionRef;\n        return this;\n    }\n    /**\n     * @param offsetPositionRef\n     * @chainable\n     */\n    setOffsetPositionRef(offsetPositionRef) {\n        this.drawParam.offsetPositionRef = offsetPositionRef;\n        return this;\n    }\n    /**\n     * @param rotationAngleRef\n     * @chainable\n     */\n    setRotationAngleRef(rotationAngleRef) {\n        this.drawParam.rotationAngleRef = rotationAngleRef;\n        return this;\n    }\n    /**\n     * @param scaleFactorRef\n     * @chainable\n     */\n    setScaleFactorRef(scaleFactorRef) {\n        this.drawParam.scaleFactorRef = scaleFactorRef;\n        return this;\n    }\n    /**\n     * @param shapeColorRef\n     * @chainable\n     */\n    setShapeColorRef(shapeColorRef) {\n        this.drawParam.shapeColorRef = shapeColorRef;\n        return this;\n    }\n    /**\n     * @param alphaChannelRef\n     * @chainable\n     */\n    setAlphaChannelRef(alphaChannelRef) {\n        this.drawParam.alphaChannelRef = alphaChannelRef;\n        return this;\n    }\n    /**\n     * @param strokeWeightRef\n     * @chainable\n     */\n    setStrokeWeightRef(strokeWeightRef) {\n        this.drawParam.strokeWeightRef = strokeWeightRef;\n        return this;\n    }\n    /**\n     * @param textSizeRef\n     * @chainable\n     */\n    setTextSizeRef(textSizeRef) {\n        this.drawParam.textSizeRef = textSizeRef;\n        return this;\n    }\n    /**\n     * Builds a p5ex.Drawer instance.\n     */\n    build() {\n        return new Drawer(this.p, this.element, this.drawParam);\n    }\n}\n/**\n * (To be filled)\n */\nclass Drawer {\n    /**\n     *\n     * @param p\n     * @param element\n     * @param drawParam\n     */\n    constructor(p, element, drawParam) {\n        this.p = p;\n        this.set(element, drawParam);\n    }\n    /**\n     * (To be filled)\n     * @param element\n     * @param drawParam\n     */\n    set(element, drawParam) {\n        this.element = element;\n        this.position = drawParam.positionRef || this.p.createVector();\n        this.offsetPosition = drawParam.offsetPositionRef || this.p.createVector();\n        this.rotation = drawParam.rotationAngleRef || NumberContainer.NULL;\n        this.scaleFactor = drawParam.scaleFactorRef || new ScaleFactor(this.p);\n        this.shapeColor = drawParam.shapeColorRef || ShapeColor.UNDEFINED;\n        this.alphaChannel = drawParam.alphaChannelRef || NumberContainer.NULL;\n        this.strokeWeight = drawParam.strokeWeightRef || NumberContainer.NULL;\n        this.textSize = drawParam.textSizeRef || NumberContainer.NULL;\n        this.procedureList = this.createProcedureList(drawParam);\n        this.procedureListLength = this.procedureList.length;\n    }\n    /**\n     * Draws the content.\n     */\n    draw() {\n        for (let i = 0, len = this.procedureListLength; i < len; i += 1) {\n            this.procedureList[i](this);\n        }\n    }\n    drawElement(drawer) {\n        drawer.element.draw();\n    }\n    createProcedureList(drawParam) {\n        const procedureList = [];\n        if (drawParam.shapeColorRef) {\n            if (drawParam.alphaChannelRef)\n                procedureList.push(this.alphaColor);\n            else\n                procedureList.push(this.color);\n        }\n        if (drawParam.textSizeRef)\n            procedureList.push(this.applyTextSize);\n        if (drawParam.strokeWeightRef)\n            procedureList.push(this.applyStrokeWeight);\n        if (drawParam.positionRef) {\n            if (drawParam.offsetPositionRef)\n                procedureList.push(this.translateWithOffset);\n            else\n                procedureList.push(this.translate);\n        }\n        else if (drawParam.offsetPositionRef)\n            procedureList.push(this.translateOnlyOffset);\n        if (drawParam.scaleFactorRef)\n            procedureList.push(this.scale);\n        if (drawParam.rotationAngleRef)\n            procedureList.push(this.rotate);\n        procedureList.push(this.drawElement);\n        if (drawParam.rotationAngleRef)\n            procedureList.push(this.cancelRotate);\n        if (drawParam.scaleFactorRef)\n            procedureList.push(this.cancelScale);\n        if (drawParam.positionRef) {\n            if (drawParam.offsetPositionRef)\n                procedureList.push(this.cancelTranslateWithOffset);\n            else\n                procedureList.push(this.cancelTranslate);\n        }\n        else if (drawParam.offsetPositionRef)\n            procedureList.push(this.cancelTranslateOnlyOffset);\n        return procedureList;\n    }\n    translate(drawer) {\n        drawer.p.currentRenderer.translate(drawer.position.x, drawer.position.y);\n    }\n    cancelTranslate(drawer) {\n        drawer.p.currentRenderer.translate(-drawer.position.x, -drawer.position.y);\n    }\n    translateOnlyOffset(drawer) {\n        drawer.p.currentRenderer.translate(drawer.offsetPosition.x, drawer.offsetPosition.y);\n    }\n    cancelTranslateOnlyOffset(drawer) {\n        drawer.p.currentRenderer.translate(-drawer.offsetPosition.x, -drawer.offsetPosition.y);\n    }\n    translateWithOffset(drawer) {\n        drawer.p.currentRenderer.translate(drawer.position.x + drawer.offsetPosition.x, drawer.position.y + drawer.offsetPosition.y);\n    }\n    cancelTranslateWithOffset(drawer) {\n        drawer.p.currentRenderer.translate(-(drawer.position.x + drawer.offsetPosition.x), -(drawer.position.y + drawer.offsetPosition.y));\n    }\n    rotate(drawer) {\n        drawer.p.currentRenderer.rotate(drawer.rotation.value);\n    }\n    cancelRotate(drawer) {\n        drawer.p.currentRenderer.rotate(-drawer.rotation.value);\n    }\n    scale(drawer) {\n        if (drawer.scaleFactor.value === 1)\n            return;\n        drawer.scaleFactor.applyScale();\n    }\n    cancelScale(drawer) {\n        if (drawer.scaleFactor.value === 1)\n            return;\n        drawer.scaleFactor.cancel();\n    }\n    color(drawer) {\n        drawer.shapeColor.applyColor();\n    }\n    alphaColor(drawer) {\n        drawer.shapeColor.applyColor(drawer.alphaChannel.value);\n    }\n    applyStrokeWeight(drawer) {\n        drawer.p.currentRenderer.strokeWeight(drawer.strokeWeight.value);\n    }\n    applyTextSize(drawer) {\n        drawer.p.currentRenderer.textSize(drawer.textSize.value);\n    }\n}\n\n/**\n * (To be filled)\n */\nclass ShapeType {\n    /**\n     * @param drawShape\n     */\n    constructor(drawShape) {\n        this.drawShape = drawShape;\n    }\n}\nconst COS60 = 1 / 2;\nconst SIN60 = Math.sqrt(3) / 2;\n\n/**\n * Set of shape types.\n */\nconst ShapeTypes = {\n    CIRCLE: new ShapeType((renderer, size) => { renderer.ellipse(0, 0, size, size); }),\n    SQUARE: new ShapeType((renderer, size) => { renderer.rect(0, 0, size, size); }),\n    REGULAR_TRIANGLE: new ShapeType((renderer, size) => {\n        const radius = 0.5 * size;\n        renderer.triangle(radius, 0, -COS60 * radius, -SIN60 * radius, -COS60 * radius, +SIN60 * radius);\n    }),\n    REGULAR_TRIANGLE_UPWARD: new ShapeType((renderer, size) => {\n        const radius = 0.5 * size;\n        renderer.triangle(0, radius, -SIN60 * radius, -COS60 * radius, +SIN60 * radius, -COS60 * radius);\n    }),\n};\n\n/**\n * (To be filled)\n */\nclass ScalableShape {\n    /**\n     *\n     * @param p5exInstance\n     * @param shapeType - type chosen from p5ex.ShapeTypes\n     * @param {number} baseShapeSize\n     * @param {NumberContainer} [scaleFactorRef]\n     */\n    constructor(p5exInstance, shapeType, baseShapeSize, scaleFactorRef = new NumberContainer(1)) {\n        this.p = p5exInstance;\n        this.shapeType = shapeType;\n        this.baseShapeSize = baseShapeSize;\n        this.scaleFactorRef = scaleFactorRef;\n    }\n    /**\n     * Draws the shape.\n     */\n    draw() {\n        this.shapeType.drawShape(this.p, this.scaleFactorRef.value * this.baseShapeSize);\n    }\n}\n\n/**\n * (To be filled)\n */\nclass LineSegment {\n    constructor(p, x1, y1, x2, y2) {\n        this.p = p;\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n    }\n    draw() {\n        this.p.currentRenderer.line(this.x1, this.y1, this.x2, this.y2);\n    }\n}\n\n/**\n * (To be filled)\n */\nclass CircularArc {\n    constructor(p, centerPosition, diameter, startAngle, endAngle, isClockwise, startRatio, endRatio) {\n        this.p = p;\n        this.centerPosition = centerPosition;\n        this.diameter = diameter;\n        this.startAngle = startAngle;\n        this.endAngle = endAngle;\n        this.startRatio = startRatio;\n        this.endRatio = endRatio;\n        this.isClockwise = isClockwise;\n    }\n    get isClockwise() { return this._isClockwise; }\n    set isClockwise(flag) {\n        this._isClockwise = flag;\n        this.validate = flag ? validateClockwise : validateAntiClockwise;\n        this.drawTrimmedArc = flag ? drawClockwise : drawAntiClockwise;\n    }\n    draw() {\n        this.validate(this);\n        const angleDifference = this.endAngle.value - this.startAngle.value;\n        const start = this.startAngle.value +\n            this.startRatio.value * angleDifference;\n        const end = this.startAngle.value +\n            this.endRatio.value * angleDifference;\n        this.drawTrimmedArc(this.p, this.centerPosition, this.diameter.value, start, end);\n    }\n}\nfunction validateClockwise(arc) {\n    if (arc.startAngle.value > arc.endAngle.value)\n        arc.endAngle.value += arc.p.TWO_PI;\n}\nfunction validateAntiClockwise(arc) {\n    if (arc.startAngle.value < arc.endAngle.value)\n        arc.endAngle.value -= arc.p.TWO_PI;\n}\nfunction drawClockwise(p, centerPosition, diameter, trimmedStartAngle, trimmedEndAngle) {\n    p.currentRenderer.arc(centerPosition.x, centerPosition.y, diameter, diameter, trimmedStartAngle, trimmedEndAngle);\n}\nfunction drawAntiClockwise(p, centerPosition, diameter, trimmedStartAngle, trimmedEndAngle) {\n    p.currentRenderer.arc(centerPosition.x, centerPosition.y, diameter, diameter, trimmedEndAngle, trimmedStartAngle);\n}\n\n// temporal vectors for use in QuadraticBezierCurve.\nconst tmpMidPoint1 = dummyP5.createVector();\nconst tmpMidPoint2 = dummyP5.createVector();\n/**\n * Trimmable quadratic bezier curve.\n */\nclass QuadraticBezierCurve {\n    /**\n     *\n     * @param p\n     * @param startPoint\n     * @param controlPoint\n     * @param endPoint\n     * @param resolution\n     * @param startRatioRef\n     * @param endRatioRef\n     */\n    constructor(p, startPoint, controlPoint, endPoint, resolution, startRatioRef, endRatioRef) {\n\n        this.pointList = new Array(resolution + 1);\n        this.resolution = resolution;\n        this.startRatio = startRatioRef;\n        this.endRatio = endRatioRef;\n        this.p = p;\n        for (let i = 0; i <= resolution; i += 1) {\n            const ratio2 = i / resolution;\n            const ratio1 = 1 - ratio2;\n            tmpMidPoint1.set(ratio1 * startPoint.x + ratio2 * controlPoint.x, ratio1 * startPoint.y + ratio2 * controlPoint.y);\n            tmpMidPoint2.set(ratio1 * controlPoint.x + ratio2 * endPoint.x, ratio1 * controlPoint.y + ratio2 * endPoint.y);\n            this.pointList[i] = p.createVector(ratio1 * tmpMidPoint1.x + ratio2 * tmpMidPoint2.x, ratio1 * tmpMidPoint1.y + ratio2 * tmpMidPoint2.y);\n        }\n    }\n    /**\n     * Returns true if the provided control point candidate is valid.\n     * @param controlPoint - The control point candidate to be checked.\n     * @param startPoint - The start point of the bezier curve.\n     * @param endPoint - The start point of the bezier curve.\n     * @param minDistance - Minimum distance between the control point and the start/end point.\n     * @param minAngle - Minimum angle of the control point.\n     * @param maxAngle - Maximum angle of the control point.\n     * @static\n     */\n    static checkControlPoint(controlPoint, startPoint, endPoint, minDistance, minAngle, maxAngle) {\n        const minDistanceSquared = minDistance * minDistance;\n        if (distSq(controlPoint, startPoint) < minDistanceSquared)\n            return false;\n        if (distSq(controlPoint, endPoint) < minDistanceSquared)\n            return false;\n        const angle = Math.abs(angleDifference(getDirectionAngle(controlPoint, startPoint), getDirectionAngle(controlPoint, endPoint)));\n        if (angle < minAngle)\n            return false;\n        if (angle > maxAngle)\n            return false;\n        return true;\n    }\n    draw() {\n        const startIndex = Math.floor(this.startRatio.value * this.resolution);\n        const endIndex = Math.floor(this.endRatio.value * this.resolution);\n        const indexRemainder = this.endRatio.value * this.resolution - endIndex;\n        const renderer = this.p.currentRenderer;\n        const points = this.pointList;\n        renderer.beginShape();\n        for (let i = startIndex; i <= endIndex; i += 1) {\n            renderer.vertex(points[i].x, points[i].y);\n        }\n        if (indexRemainder > 0) {\n            renderer.vertex(points[endIndex].x + indexRemainder * (points[endIndex + 1].x - points[endIndex].x), points[endIndex].y + indexRemainder * (points[endIndex + 1].y - points[endIndex].y));\n        }\n        renderer.endShape();\n    }\n}\n\n/**\n * Draws a sine wave.\n * @param p\n * @param drawingLength\n * @param peakToPeakAmplitude\n * @param waveLength\n */\nfunction drawSineWave(p, drawingLength, peakToPeakAmplitude, waveLength) {\n    const renderer = p.currentRenderer;\n    const peakAmplitude = 0.5 * peakToPeakAmplitude;\n    let reachedEnd = false;\n    renderer.beginShape();\n    for (let x = 0; x <= drawingLength; x += 1) {\n        if (x > drawingLength)\n            reachedEnd = true;\n        renderer.vertex(reachedEnd ? drawingLength : x, -peakAmplitude * Math.sin(p.TWO_PI * x / waveLength));\n        if (reachedEnd)\n            break;\n    }\n    renderer.endShape();\n}\n/**\n * Set color to the specified pixel.\n * Should be used in conjunction with loadPixels() and updatePixels().\n * @param renderer - Instance of either p5 or p5.Graphics.\n * @param x - The x index of the pixel.\n * @param y - The y index of the pixel.\n * @param red - The red value (0 - 255).\n * @param green - The green value (0 - 255).\n * @param blue - The blue value (0 - 255).\n * @param pixelDensity - If not specified, renderer.pixelDensity() will be called.\n */\nfunction setPixel(renderer, x, y, red, green, blue, alpha, pixelDensity) {\n    const g = renderer;\n    const d = pixelDensity || g.pixelDensity();\n    for (let i = 0; i < d; i += 1) {\n        for (let j = 0; j < d; j += 1) {\n            const idx = 4 * ((y * d + j) * g.width * d + (x * d + i));\n            g.pixels[idx] = red;\n            g.pixels[idx + 1] = green;\n            g.pixels[idx + 2] = blue;\n            g.pixels[idx + 3] = alpha;\n        }\n    }\n}\n/**\n * Lerp color to the specified pixel. The alpha channel remains unchanged.\n * Should be used in conjunction with loadPixels() and updatePixels().\n * @param renderer - Instance of either p5 or p5.Graphics.\n * @param x - The x index of the pixel.\n * @param y - The y index of the pixel.\n * @param red - The red value (0 - 255).\n * @param green - The green value (0 - 255).\n * @param blue - The blue value (0 - 255).\n * @param pixelDensity - If not specified, renderer.pixelDensity() will be called.\n * @param lerpRatio - The lerp ratio (0 - 1). If 1, the color will be replaced.\n */\nfunction lerpPixel(renderer, x, y, red, green, blue, pixelDensity, lerpRatio = 1) {\n    const g = renderer;\n    const d = pixelDensity || g.pixelDensity();\n    for (let i = 0; i < d; i += 1) {\n        for (let j = 0; j < d; j += 1) {\n            const idx = 4 * ((y * d + j) * g.width * d + (x * d + i));\n            g.pixels[idx] = lerp(g.pixels[idx], red, lerpRatio);\n            g.pixels[idx + 1] = lerp(g.pixels[idx + 1], green, lerpRatio);\n            g.pixels[idx + 2] = lerp(g.pixels[idx + 2], blue, lerpRatio);\n            // g.pixels[idx + 3] = 255;\n        }\n    }\n}\n/**\n * Fill the canvas or graphics (according to p.currentRenderer) with gradation.\n * @param p\n * @param backgroundColor\n * @param fromColor\n * @param toColor\n * @param lerpRatioExponent\n */\nfunction gradationBackground(p, backgroundColor, fromColor, toColor, lerpRatioExponent = 1) {\n    const g = p.currentRenderer;\n    g.background(backgroundColor);\n    g.strokeWeight(2);\n    for (let y = 0; y < g.width; y += 1) {\n        const lerpRatio = Math.pow(y / (g.height - 1), lerpRatioExponent);\n        g.stroke(p.lerpColor(fromColor, toColor, lerpRatio));\n        g.line(0, y, g.width - 1, y);\n    }\n}\nfunction lerpPixelForRandomTexture(renderer, x, y, red, green, blue, alpha) {\n    lerpPixel(renderer, x, y, red, green, blue, undefined, alpha / 255);\n}\n/**\n * Sets the specified color (default: black) to each pixel with a random alpha value.\n * @param renderer - Instance of either p5 or p5.Graphics.\n * @param {number} maxAlpha - The max value of alpha channel (1 - 255).\n * @param {boolean} [blend] - Set true for blending, false for replacing.\n * @param {number} [red]\n * @param {number} [green]\n * @param {number} [blue]\n */\nfunction applyRandomTexture(renderer, maxAlpha, blend = true, red = 0, green = 0, blue = 0) {\n    const g = renderer;\n    const width = g.width;\n    const height = g.height;\n    const operatePixel = blend ? lerpPixelForRandomTexture : setPixel;\n    g.loadPixels();\n    for (let y = 0; y < height; y += 1) {\n        for (let x = 0; x < width; x += 1) {\n            operatePixel(renderer, x, y, red, green, blue, Math.random() * maxAlpha);\n        }\n    }\n    g.updatePixels();\n    return g;\n}\n\n/**\n * Font class.\n */\nclass FontUnit {\n    /**\n     *\n     * @param p - p5ex instance.\n     * @param {string} name - The font name.\n     * @param {string} [filePath] - The file path of the font.\n     *     Not required if the font is already loaded (e.g. as a web font).\n     */\n    constructor(p, name, filePath) {\n        this.p = p;\n        this.filePath = filePath || null;\n        this.textFontArgument = name;\n    }\n    /**\n     * Loads the font file if the file path has been specified.\n     */\n    loadFile() {\n        if (this.filePath)\n            this.textFontArgument = this.p.loadFont(this.filePath);\n    }\n    /**\n     * Applies the font to the current renderer.\n     */\n    applyFont() {\n        this.p.currentRenderer.textFont(this.textFontArgument);\n    }\n}\n/**\n * Manager class of FontUnit.\n */\nclass FontManager {\n    /**\n     *\n     * @param p - p5ex instance.\n     */\n    constructor(p) {\n        this.p = p;\n        this.fontMap = new Map();\n    }\n    /**\n     * Registers a new font.\n     * @param p\n     * @param name\n     * @param filePath\n     * @chainable\n     */\n    register(name, filePath) {\n        this.fontMap.set(name, new FontUnit(this.p, name, filePath));\n        return this;\n    }\n    /**\n     * Calls loadFile() for each registered font. Should be called in preload().\n     */\n    loadAll() {\n        for (const font of this.fontMap.values()) {\n            font.loadFile();\n        }\n    }\n    /**\n     * Applies the specified font to the current renderer.\n     * @param {string} name - The font name.\n     */\n    applyFont(name) {\n        const font = this.fontMap.get(name);\n        if (font)\n            font.applyFont();\n    }\n}\n\n/**\n * (To be filled)\n */\nclass AngleQuantity {\n    /**\n     * Null object of AngleQuantity.\n     * @static\n     */\n    static get NULL() { return NULL$1; }\n    /**\n     *\n     * @param angle\n     * @param angleVelocity\n     */\n    constructor(angle = 0, angleVelocity = 0) {\n        this.angleReference = new NumberContainer(angle);\n        this.angleVelocityReference = new NumberContainer(angleVelocity);\n    }\n    /**\n     * Current angle value.\n     */\n    get angle() { return this.angleReference.value; }\n    set angle(v) { this.angleReference.value = v; }\n    /**\n     * Current anglular velocity value.\n     */\n    get angleVelocity() { return this.angleVelocityReference.value; }\n    set angleVelocity(v) { this.angleVelocityReference.value = v; }\n    /**\n     * Updates the angle.\n     */\n    step() {\n        this.angle += this.angleVelocity;\n    }\n}\nclass NullAngleQuantity extends AngleQuantity {\n    get angle() { return 0; }\n    set angle(v) { }\n    get angleVelocity() { return 0; }\n    set angleVelocity(v) { }\n    step() { }\n}\nconst NULL$1 = new NullAngleQuantity();\n\n/**\n * (To be filled)\n */\nclass KinematicQuantity {\n    constructor() {\n        this.position = new p5.Vector();\n        this.velocity = new p5.Vector();\n    }\n    /**\n     * Updates the position.\n     */\n    step() {\n        this.position.add(this.velocity);\n    }\n    /**\n     * Returns the current speed.\n     */\n    getSpeed() {\n        return this.velocity.mag();\n    }\n    /**\n     * Returns the current direction angle.\n     */\n    getDirection() {\n        return this.velocity.heading();\n    }\n    /**\n     * Adds the given value to the current speed.\n     * @param speedChange\n     */\n    addSpeed(speedChange) {\n        this.velocity.setMag(Math.max(0, this.velocity.mag() + speedChange));\n    }\n}\n\nconst temporalVector = dummyP5.createVector();\n/**\n * (To be filled)\n */\nclass PhysicsBody {\n    constructor() {\n        this.kinematicQuantity = new KinematicQuantity();\n        this.position = this.kinematicQuantity.position;\n        this.velocity = this.kinematicQuantity.velocity;\n        this.mass = 1;\n        this.collisionRadius = 0;\n        this.hasFriction = false;\n        this.decelerationFactor = 1;\n    }\n    /**\n     * X position.\n     */\n    get x() {\n        return this.position.x;\n    }\n    /**\n     * Y position.\n     */\n    get y() {\n        return this.position.y;\n    }\n    /**\n     * Z position.\n     */\n    get z() {\n        return this.position.z;\n    }\n    /**\n     * X velocity.\n     */\n    get vx() {\n        return this.velocity.x;\n    }\n    /**\n     * Y velocity.\n     */\n    get vy() {\n        return this.velocity.y;\n    }\n    /**\n     * Z velocity.\n     */\n    get vz() {\n        return this.velocity.z;\n    }\n    /**\n     * Returns the current speed.\n     */\n    getSpeed() {\n        return this.kinematicQuantity.getSpeed();\n    }\n    /**\n     * Returns the current direction angle.\n     */\n    getDirection() {\n        return this.kinematicQuantity.getDirection();\n    }\n    /**\n     * Sets the friction of the body.\n     * @param constant\n     */\n    setFriction(constant) {\n        if (constant === 0) {\n            this.hasFriction = false;\n            return;\n        }\n        this.hasFriction = true;\n        this.decelerationFactor = 1 - constant;\n    }\n    /**\n     * Constrains the current speed. Should be called every time if needed.\n     * @param maxSpeed\n     */\n    constrainSpeed(maxSpeed) {\n        if (this.velocity.magSq() > maxSpeed * maxSpeed)\n            this.velocity.setMag(maxSpeed);\n    }\n    /**\n     * Updates the body.\n     */\n    step() {\n        this.kinematicQuantity.step();\n        if (this.hasFriction) {\n            this.kinematicQuantity.velocity.mult(this.decelerationFactor);\n        }\n    }\n    /**\n     * Accelerates the body.\n     * @param x\n     * @param y\n     * @param z\n     */\n    accelerate(x, y, z) {\n        this.kinematicQuantity.velocity.add(x, y, z);\n    }\n    /**\n     * Apply the provided force to the body.\n     * @param force\n     */\n    applyForce(force) {\n        this.accelerate(force.x / this.mass, force.y / this.mass, force.z / this.mass);\n    }\n    /**\n     * Add the provided value to the speed of the body.\n     * @param speedChange\n     */\n    addSpeed(speedChange) {\n        this.kinematicQuantity.addSpeed(speedChange);\n    }\n    /**\n     * Returns true if the body collides the provided body.\n     * @param other\n     */\n    collides(other) {\n        return (distSq(this.position, other.position) <\n            this.collisionRadius * this.collisionRadius + other.collisionRadius * other.collisionRadius);\n    }\n    /**\n     * (To be filled)\n     * @param normalUnitVector\n     * @param restitution\n     */\n    bounce(normalUnitVector, restitution = 1) {\n        this.velocity.add(p5.Vector.mult(normalUnitVector, (1 + restitution) * p5.Vector.dot(this.velocity, p5.Vector.mult(normalUnitVector, -1))));\n    }\n    /**\n     * Applies attraction force to both this and the target body.\n     * @param {PhysicsBody} other - the other body to interact with\n     * @param {number} magnitudeFactor - the factor of magnitude other than the distance\n     * @param {number} minMag - the minimum magnitude\n     * @param {number} maxMag - the maximum magnitude\n     * @param {number} cutoffMag - does not apply force if magnitude is smaller than this\n     */\n    attractEachOther(other, magnitudeFactor, minMag = 0, maxMag, cutoffMag) {\n        const force = this.calculateAttractionForce(other.position, magnitudeFactor, minMag, maxMag, cutoffMag);\n        if (!force)\n            return;\n        this.applyForce(force);\n        force.mult(-1);\n        other.applyForce(force);\n    }\n    /**\n     * Applies attraction force to this body.\n     * @param {p5.Vector} targetPosition - the target position\n     * @param {number} magnitudeFactor - the factor of magnitude other than the distance\n     * @param {number} minMag - the minimum magnitude\n     * @param {number} maxMag - the maximum magnitude\n     * @param {number} cutoffMag - does not apply force if magnitude is smaller than this\n     */\n    attractToPoint(targetPosition, magnitudeFactor, minMag = 0, maxMag, cutoffMag) {\n        const force = this.calculateAttractionForce(targetPosition, magnitudeFactor, minMag, maxMag, cutoffMag);\n        if (!force)\n            return;\n        this.applyForce(force);\n    }\n    calculateAttractionForce(targetPosition, magnitudeFactor, minMag = 0, maxMag, cutoffMag) {\n        const tmpVec = temporalVector;\n        p5.Vector.sub(targetPosition, this.position, tmpVec); // set relative position\n        const distanceSquared = tmpVec.magSq();\n        let magnitude = Math.abs(magnitudeFactor) / distanceSquared;\n        if (cutoffMag && magnitude < cutoffMag)\n            return null;\n        if (maxMag)\n            magnitude = Math.min(Math.max(magnitude, minMag), maxMag);\n        else\n            magnitude = Math.max(magnitude, minMag);\n        tmpVec.setMag(magnitude); // set force\n        if (magnitudeFactor < 0)\n            tmpVec.mult(-1);\n        return tmpVec;\n    }\n}\n\n/**\n * Returns the 2D force vector which is to be applied to the load.\n * @param loadDirectionAngle - the direction angle from the fulcrum to the load\n * @param loadDistance - the distance between the fulcrum and the load\n * @param effortDistance - the distance between the fulcrum and the effort\n * @param effortForceMagnitude - the effort force magnitude\n * @param rotateClockwise - true if the load is to be rotated clockwise, otherwise false\n * @param target - the vector to receive the result. Will be newly created if not specified\n */\nfunction calculateLeverageForce(loadDirectionAngle, loadDistance, effortDistance, effortForceMagnitude, rotateClockwise, target) {\n    const force = target || dummyP5.createVector();\n    const forceDirectionAngle = loadDirectionAngle + (rotateClockwise ? -dummyP5.HALF_PI : dummyP5.HALF_PI);\n    force.set(Math.cos(forceDirectionAngle), Math.sin(forceDirectionAngle));\n    force.setMag(effortForceMagnitude * effortDistance / loadDistance); // load force\n    return force;\n}\n\n/**\n * (To be filled)\n */\nclass FrameCounter {\n    constructor() {\n        this.count = 0;\n    }\n    /**\n     * Resets the counter.\n     * @param count\n     */\n    resetCount(count = 0) {\n        this.count = count;\n        return this;\n    }\n    /**\n     * Increments the frame count.\n     */\n    step() {\n        this.count += 1;\n    }\n    /**\n     * Returns the mod.\n     * @param divisor\n     */\n    mod(divisor) {\n        return this.count % divisor;\n    }\n}\n\n/**\n * (To be filled)\n */\nclass TimedFrameCounter extends FrameCounter {\n    /**\n     * True if this counter is activated.\n     */\n    get isOn() { return this._isOn; }\n\n    /**\n     *\n     * @param durationFrameCount\n     * @param completeBehavior\n     */\n    constructor(durationFrameCount, completeBehavior = EMPTY_FUNCTION) {\n        super();\n        this._isOn = true;\n        this.completeBehavior = completeBehavior;\n        this.durationFrameCount = durationFrameCount;\n    }\n    /**\n     * Activate this counter.\n     * @param duration\n     * @chainable\n     */\n    on(duration) {\n        this._isOn = true;\n        if (duration)\n            this.durationFrameCount = duration;\n        return this;\n    }\n    /**\n     * Deactivate this counter.\n     * @chainable\n     */\n    off() {\n        this._isOn = false;\n        return this;\n    }\n    /**\n     * @override\n     */\n    step() {\n        if (!this._isOn)\n            return;\n        this.count += 1;\n        if (this.count > this.durationFrameCount) {\n            this.completeCycle();\n        }\n    }\n}\n\n/**\n * (To be filled)\n */\nclass LoopedFrameCounter extends TimedFrameCounter {\n    /**\n     *\n     * @param duration\n     * @param cycleCompleteBehavior\n     */\n    constructor(duration, cycleCompleteBehavior) {\n        super(duration, cycleCompleteBehavior);\n    }\n    /**\n     * @override\n     * @chainable\n     */\n    on(duration) {\n        super.on(duration);\n        return this;\n    }\n    /**\n     * @override\n     * @chainable\n     */\n    off() {\n        super.off();\n        return this;\n    }\n    /**\n     * @override\n     */\n    getProgressRatio() {\n        return this.count / this.durationFrameCount;\n    }\n    /**\n     * @override\n     */\n    completeCycle() {\n        this.completeBehavior();\n        this.count = 0;\n    }\n}\n\n/**\n * (To be filled)\n */\nclass NonLoopedFrameCounter extends TimedFrameCounter {\n    /**\n     * True if the given frame count duration has ellapsed already.\n     */\n    get isCompleted() { return this._isCompleted; }\n\n    /**\n     *\n     * @param durationFrameCount\n     * @param completeBehavior\n     */\n    constructor(durationFrameCount, completeBehavior) {\n        super(durationFrameCount, completeBehavior);\n        this._isCompleted = false;\n    }\n    /**\n     * @override\n     * @chainable\n     */\n    on(duration) {\n        super.on(duration);\n        return this;\n    }\n    /**\n     * @override\n     * @chainable\n     */\n    off() {\n        super.off();\n        return this;\n    }\n    /**\n     * @override\n     */\n    resetCount() {\n        super.resetCount();\n        this._isCompleted = false;\n        return this;\n    }\n    /**\n     * @override\n     */\n    getProgressRatio() {\n        return this._isCompleted ? 1 : this.count / this.durationFrameCount;\n    }\n    /**\n     * @override\n     */\n    completeCycle() {\n        this._isCompleted = true;\n        this._isOn = false;\n        this.completeBehavior();\n    }\n}\n\n/**\n * Holds a boolean value for each key which indicates if the key is currently down.\n */\nconst keyDown = new Map();\n/**\n * Begins to listen key events. Default behaviors for arrow keys will be prevented.\n */\nfunction listenKey() {\n    window.addEventListener('keydown', (event) => {\n        keyDown.set(event.key, true);\n        keyDown.set(event.code, true);\n        switch (event.key) {\n            case 'ArrowDown':\n            case 'ArrowUp':\n            case 'ArrowLeft':\n            case 'ArrowRight':\n                return false;\n            default:\n                return;\n        }\n    });\n    window.addEventListener('keyup', (event) => {\n        keyDown.set(event.key, false);\n        keyDown.set(event.code, false);\n        switch (event.key) {\n            case 'ArrowDown':\n            case 'ArrowUp':\n            case 'ArrowLeft':\n            case 'ArrowRight':\n                return false;\n            default:\n                return;\n        }\n    });\n}\n\n/**\n * Returns true if the mouse cursor is on the canvas.\n * @param p - p5ex instance.\n */\nfunction mouseOnCanvas(p) {\n    if (p.mouseX < 0)\n        return false;\n    if (p.mouseX > p.width)\n        return false;\n    if (p.mouseY < 0)\n        return false;\n    if (p.mouseY > p.height)\n        return false;\n    return true;\n}\n\n/**\n * Extension of p5 class.\n */\n\nclass p5exClass extends p5 {\n    /**\n     * Sets the current renderer object.\n     * @param renderer\n     */\n    setCurrentRenderer(renderer) {\n        this.currentRenderer = renderer;\n    }\n    /**\n      * The non-scaled width of the canvas.\n      */\n    get nonScaledWidth() {\n        return this.scalableCanvas.nonScaledWidth;\n    }\n    /**\n     * The non-scaled height of the canvas.\n     */\n    get nonScaledHeight() {\n        return this.scalableCanvas.nonScaledHeight;\n    }\n\n    /**\n     * The ideal frame rate which was set by setFrameRate().\n     */\n    get idealFrameRate() { return this._idealFrameRate; }\n    /**\n     * Anglular displacement in radians per frame which corresponds to 1 cycle per second.\n     * Set by setFrameRate().\n     */\n    get unitAngleSpeed() { return this._unitAngleSpeed; }\n    /**\n     * Positional displacement per frame which corresponds to 1 unit length per second.\n     * Set by setFrameRate().\n     */\n    get unitSpeed() { return this._unitSpeed; }\n    /**\n     * Change of speed per frame which corresponds to 1 unit speed per second.\n     * Set by setFrameRate().\n     */\n    get unitAccelerationMagnitude() { return this._unitAccelerationMagnitude; }\n    /**\n     * Constructor of class p5ex.\n     * @param sketch\n     * @param node\n     * @param sync\n     */\n    constructor(sketch, node, sync) {\n        super(sketch, typeof node === 'string' ? document.getElementById(node) || undefined : node, sync);\n        if (!node || typeof node === 'boolean') {\n            this.node = document.body;\n        }\n        else {\n            this.node = typeof node === 'string' ? document.getElementById(node) || document.body : node;\n        }\n        this.currentRenderer = this;\n        this.maxCanvasRegion = {\n            width: 0,\n            height: 0,\n            getShortSideLength() { return Math.min(this.width, this.height); },\n        };\n        this.updateMaxCanvasRegion();\n        this.setFrameRate();\n    }\n    /**\n     * Calls frameRate() and sets variables related to the frame rate.\n     * @param {number} [fps=60] - The ideal frame rate per second.\n     */\n    setFrameRate(fps = 60) {\n        this.frameRate(fps);\n        if (fps) {\n            this._idealFrameRate = fps;\n            this._unitAngleSpeed = 2 * Math.PI / this._idealFrameRate;\n            this._unitSpeed = 1 / this._idealFrameRate;\n            this._unitAccelerationMagnitude = this._unitSpeed / this._idealFrameRate;\n        }\n        return this;\n    }\n    /**\n     * Updates the value of the variable maxCanvasRegion.\n     */\n    updateMaxCanvasRegion() {\n        this.maxCanvasRegion.width = this.windowWidth;\n        this.maxCanvasRegion.height = this.windowHeight;\n        if (this.node === document.body)\n            return;\n        const containerRect = this.node.getBoundingClientRect();\n        this.maxCanvasRegion.width = containerRect.width;\n        this.maxCanvasRegion.height = containerRect.height;\n    }\n    /**\n     * Create an instance of ScalableCanvas. This includes calling of createCanvas().\n     * @param {ScalableCanvasType} type - Type chosen from p5ex.ScalableCanvasTypes.\n     * @param {ScalableCanvasParameters} [parameters] - Parameters for type CUSTOM.\n     * @param {string} [rendererType] - Either P2D or WEBGL.\n     */\n    createScalableCanvas(type, parameters, rendererType) {\n        this.scalableCanvasType = type;\n        this.scalableCanvas = new ScalableCanvas(this, this.createScalableCanvasParameter(type, parameters), this.node, rendererType);\n    }\n    /**\n     * Resizes the ScalableCanvas. Does not work on OpenProcessing.\n     * @param {ScalableCanvasType} [type] - Type chosen from p5ex.ScalableCanvasTypes.\n     *     If undefined, the last used type will be used again.\n     * @param {ScalableCanvasParameters} [parameters] - Parameters for type CUSTOM.\n     */\n    resizeScalableCanvas(type, parameters) {\n        this.scalableCanvas.resize(this.createScalableCanvasParameter(type || this.scalableCanvasType, parameters));\n    }\n    createScalableCanvasParameter(type, parameters) {\n        this.updateMaxCanvasRegion();\n        const maxShortSide = this.maxCanvasRegion.getShortSideLength();\n        switch (type) {\n            case ScalableCanvasTypes.SQUARE640x640:\n                return {\n                    scaledWidth: maxShortSide,\n                    scaledHeight: maxShortSide,\n                    nonScaledShortSideLength: 640,\n                };\n            case ScalableCanvasTypes.RECT640x480:\n                return {\n                    scaledWidth: maxShortSide,\n                    scaledHeight: 0.75 * maxShortSide,\n                    nonScaledShortSideLength: 480,\n                };\n            case ScalableCanvasTypes.FULL:\n                return {\n                    scaledWidth: this.maxCanvasRegion.width,\n                    scaledHeight: this.maxCanvasRegion.height,\n                    nonScaledShortSideLength: 640,\n                };\n            default:\n                return parameters || ScalableCanvas.DUMMY_PARAMETERS;\n        }\n    }\n}\n\nexport { p5exClass, loopArray, loopArrayBackwards, roundRobin, nestedLoopJoin, LoopableArray, EMPTY_FUNCTION, distSq, multiplyMatrixAndArray, angleDifference, getDirectionAngle, lerp, randomBetween, randomInt, randomIntBetween, getRandom, popRandom, randomSign, NumberContainer, WeightedRandomSelector, easeLinear, easeOutQuad, easeOutCubic, easeOutQuart, easeOutBack, getEasingFunction, dummyP5, Region, RectangleRegion, ScalableCanvas, ScalableCanvasTypes, ScreenEffect, ScreenShake, ScreenFlash, AlphaBackground, mouseIsInCanvas, TwoDimensionalArray, NaiveEdge, NaiveCell, NullCell, Grid, DrawableArray, SteppableArray, SpriteArray, CleanableArray, CleanableSpriteArray, ObjectPool, PoolableArray, ShapeColor, RandomShapeColor, setIlluminant, cielabColor, cielchColor, Illuminants, degamma, subtractColor, hsbColor, Drawer, DrawerBuilder, ShapeType, ShapeTypes, ScalableShape, LineSegment, CircularArc, QuadraticBezierCurve, drawSineWave, setPixel, lerpPixel, gradationBackground, applyRandomTexture, FontUnit, FontManager, ScaleFactor, AngleQuantity, KinematicQuantity, PhysicsBody, calculateLeverageForce, FrameCounter, LoopedFrameCounter, NonLoopedFrameCounter, keyDown, listenKey, mouseOnCanvas };\n","export function createGradationRectangle(\r\n  p: p5,\r\n  w: number,\r\n  h: number,\r\n  backgroundColor: p5.Color,\r\n  fromColor: p5.Color,\r\n  toColor: p5.Color,\r\n  gradient: number = 1,\r\n  interval: number = 1\r\n): p5.Graphics {\r\n  const g = p.createGraphics(w, h) as any;\r\n  g.background(backgroundColor);\r\n  g.strokeWeight(interval * 2);\r\n\r\n  for (let y = 0; y < h; y += interval) {\r\n    const lerpRatio = Math.pow(y / (h - 1), gradient);\r\n    g.stroke(p.lerpColor(fromColor, toColor, lerpRatio));\r\n    g.line(0, y, w - 1, y);\r\n  }\r\n\r\n  return g;\r\n}\r\n\r\nexport interface ObjectPool<T> {\r\n  array: T[];\r\n  size: number;\r\n}\r\n\r\nexport function createObjectPool<T>(\r\n  instanceFactory: () => T,\r\n  initialSize: number\r\n): ObjectPool<T> {\r\n  const array: T[] = [];\r\n  for (let i = 0; i < initialSize; i++) array.push(instanceFactory());\r\n  return {\r\n    array: array,\r\n    size: array.length\r\n  };\r\n}\r\n\r\nexport function useObject<T>(pool: ObjectPool<T>): T {\r\n  const nextSize = pool.size - 1;\r\n  pool.size = nextSize;\r\n  return pool.array[nextSize];\r\n}\r\n\r\nexport function recycleObject<T>(pool: ObjectPool<T>, usedObject: T): void {\r\n  pool.array[pool.size++] = usedObject;\r\n}\r\n","import * as p5ex from \"p5ex\";\r\nimport {\r\n  createGradationRectangle,\r\n  createObjectPool,\r\n  useObject,\r\n  recycleObject,\r\n  ObjectPool\r\n} from \"./functions\";\r\n\r\nconst SKETCH_NAME = \"Traffic\";\r\n\r\nconst enum Bound {\r\n  TOP,\r\n  BOTTOM,\r\n  LEFT,\r\n  RIGHT\r\n}\r\n\r\ninterface EndPoint {\r\n  position: p5.Vector;\r\n  velocity: number;\r\n  acceleration: number;\r\n  bound: Bound;\r\n}\r\n\r\ninterface Road {\r\n  startPoint: EndPoint;\r\n  endPoint: EndPoint;\r\n  intersectionList: Intersection[];\r\n}\r\n\r\ninterface Vehicle {\r\n  road: Road;\r\n  positionRatio: number;\r\n  positionRatioChangeRate: number;\r\n  positionRatioTotalChange: number;\r\n  acceleration: number;\r\n  roadChangeEffectTimer: p5ex.NonLoopedFrameCounter;\r\n}\r\n\r\ninterface Intersection {\r\n  roadA: Road;\r\n  positionRatioA: number;\r\n  roadB: Road;\r\n  positionRatioB: number;\r\n}\r\n\r\ninterface ReadonlyNumberRange {\r\n  readonly start: number;\r\n  readonly end: number;\r\n}\r\n\r\nconst sketch = (p: p5ex.p5exClass): void => {\r\n  // ---- constants\r\n  const DRAW_INTERSECTIONS = false;\r\n  const boundArray = [Bound.TOP, Bound.BOTTOM, Bound.LEFT, Bound.RIGHT];\r\n  const ROAD_COUNT = 24;\r\n  const ROAD_STROKE_WEIGHT = 1;\r\n  const VEHICLE_COUNT = 64;\r\n  const VEHICLE_SIZE = 12;\r\n  const VEHICLE_STROKE_WEIGHT = 2;\r\n  const VEHICLE_EXPAND_MAX_RATIO = 0.2;\r\n  const VEHICLE_EXPAND_TIME_SCALE = 60;\r\n  const INTERSECTION_SIZE = 5;\r\n  const MAX_INTERSECTION_COUNT = ROAD_COUNT * ROAD_COUNT;\r\n  const POSITION_RATIO_DISTANCE_THREASHOLD = 0.0025;\r\n  const ROAD_CHANGE_EFFECT_DURATION = 30;\r\n  const END_POINT_VELOCITY_RANGE: ReadonlyNumberRange = {\r\n    start: -0.5,\r\n    end: 0.5\r\n  };\r\n  const END_POINT_ACCELERATION_RANGE: ReadonlyNumberRange = {\r\n    start: -0.05,\r\n    end: 0.05\r\n  };\r\n  const VEHICLE_POSITION_CHANGE_RATE_RANGE: ReadonlyNumberRange = {\r\n    start: 0.002,\r\n    end: 0.005\r\n  };\r\n  const VEHICLE_ACCELERATION_RANGE: ReadonlyNumberRange = {\r\n    start: -0.0001,\r\n    end: 0.0001\r\n  };\r\n  const END_POINT_ACCELERATION_CHANGE_PROBABILITY = 0.01;\r\n  const VEHICLE_ACCELERATION_CHANGE_PROBABILITY = 0.02;\r\n  const ROAD_CHANGE_POSSIBILITY = 0.75;\r\n\r\n  // variables\r\n  let intersectionPool: ObjectPool<Intersection>;\r\n  let usedIntersections: p5ex.LoopableArray<Intersection>;\r\n  let backgroundPixels: number[];\r\n  let roads: p5ex.LoopableArray<Road>;\r\n  let vehicles: p5ex.LoopableArray<Vehicle>;\r\n  let roadColor: p5ex.ShapeColor;\r\n  let vehicleColor: p5ex.ShapeColor;\r\n  let activeVehicleColor: p5ex.ShapeColor;\r\n\r\n  // ---- functions\r\n  function randomIn(range: ReadonlyNumberRange): number {\r\n    return p.random(range.start, range.end);\r\n  }\r\n\r\n  function constrainInRange(value: number, range: ReadonlyNumberRange): number {\r\n    return p.constrain(value, range.start, range.end);\r\n  }\r\n\r\n  function drawCircleOnLineSegment(\r\n    startPosition: p5.Vector,\r\n    endPosition: p5.Vector,\r\n    positionRatio: number,\r\n    diameter: number\r\n  ): void {\r\n    p.ellipse(\r\n      p.lerp(startPosition.x, endPosition.x, positionRatio),\r\n      p.lerp(startPosition.y, endPosition.y, positionRatio),\r\n      diameter,\r\n      diameter\r\n    );\r\n  }\r\n\r\n  function createEndPoint(bound: Bound): EndPoint {\r\n    let x: number;\r\n    let y: number;\r\n    const ratio = p.random(0.2, 0.8);\r\n\r\n    switch (bound) {\r\n      default:\r\n      case Bound.TOP:\r\n        x = ratio * p.width;\r\n        y = 0;\r\n        break;\r\n      case Bound.BOTTOM:\r\n        x = ratio * p.width;\r\n        y = p.height;\r\n        break;\r\n      case Bound.LEFT:\r\n        x = 0;\r\n        y = ratio * p.height;\r\n        break;\r\n      case Bound.RIGHT:\r\n        x = p.width;\r\n        y = ratio * p.height;\r\n        break;\r\n    }\r\n\r\n    return {\r\n      position: p.createVector(x, y),\r\n      velocity: 0,\r\n      acceleration: 0,\r\n      bound: bound\r\n    };\r\n  }\r\n\r\n  function createRoad(): Road {\r\n    const startPointBound: Bound = p.random(boundArray);\r\n    const endPointBound: Bound = p.random(\r\n      boundArray.filter(b => b != startPointBound)\r\n    );\r\n\r\n    return {\r\n      startPoint: createEndPoint(startPointBound),\r\n      endPoint: createEndPoint(endPointBound),\r\n      intersectionList: []\r\n    };\r\n  }\r\n\r\n  function updateEndPoint(endPoint: EndPoint): void {\r\n    if (Math.random() < END_POINT_ACCELERATION_CHANGE_PROBABILITY)\r\n      endPoint.acceleration = randomIn(END_POINT_ACCELERATION_RANGE);\r\n\r\n    endPoint.velocity = constrainInRange(\r\n      endPoint.velocity + endPoint.acceleration,\r\n      END_POINT_VELOCITY_RANGE\r\n    );\r\n\r\n    const position = endPoint.position;\r\n    switch (endPoint.bound) {\r\n      case Bound.TOP:\r\n      case Bound.BOTTOM:\r\n        position.x += endPoint.velocity;\r\n        if (position.x < 0) {\r\n          position.x = 1;\r\n          endPoint.velocity = 0;\r\n          endPoint.acceleration = END_POINT_ACCELERATION_RANGE.end * 2;\r\n        } else if (position.x > p.width) {\r\n          position.x = p.width - 1;\r\n          endPoint.velocity = 0;\r\n          endPoint.acceleration = END_POINT_ACCELERATION_RANGE.start * 2;\r\n        }\r\n        break;\r\n      case Bound.LEFT:\r\n      case Bound.RIGHT:\r\n        position.y += endPoint.velocity;\r\n        if (position.y < 0) {\r\n          position.y = 1;\r\n          endPoint.velocity = 0;\r\n          endPoint.acceleration = END_POINT_ACCELERATION_RANGE.end * 2;\r\n        } else if (position.y > p.height) {\r\n          position.y = p.height - 1;\r\n          endPoint.velocity = 0;\r\n          endPoint.acceleration = END_POINT_ACCELERATION_RANGE.start * 2;\r\n        }\r\n        break;\r\n    }\r\n  }\r\n\r\n  function updateRoad(road: Road): void {\r\n    updateEndPoint(road.startPoint);\r\n    updateEndPoint(road.endPoint);\r\n  }\r\n\r\n  function drawRoad(road: Road): void {\r\n    const startPosition = road.startPoint.position;\r\n    const endPosition = road.endPoint.position;\r\n    p.line(startPosition.x, startPosition.y, endPosition.x, endPosition.y);\r\n  }\r\n\r\n  function drawIntersection(intersection: Intersection): void {\r\n    const road = intersection.roadA;\r\n    const startPosition = road.startPoint.position;\r\n    const endPosition = road.endPoint.position;\r\n    drawCircleOnLineSegment(\r\n      startPosition,\r\n      endPosition,\r\n      intersection.positionRatioA,\r\n      INTERSECTION_SIZE\r\n    );\r\n  }\r\n\r\n  function clearIntersections(road: Road): void {\r\n    road.intersectionList.length = 0;\r\n  }\r\n\r\n  function tryAddIntersection(roadA: Road, roadB: Road): void {\r\n    const A = roadA.startPoint.position;\r\n    const B = roadA.endPoint.position;\r\n    const C = roadB.startPoint.position;\r\n    const D = roadB.endPoint.position;\r\n\r\n    let divider = (B.x - A.x) * (D.y - C.y) - (B.y - A.y) * (D.x - C.x);\r\n    if (divider == 0) return;\r\n\r\n    const ACx = C.x - A.x;\r\n    const ACy = C.y - A.y;\r\n\r\n    const ratioA = ((D.y - C.y) * ACx - (D.x - C.x) * ACy) / divider;\r\n    if (ratioA < 0 || ratioA > 1) return;\r\n\r\n    const ratioB = ((B.y - A.y) * ACx - (B.x - A.x) * ACy) / divider;\r\n    if (ratioB < 0 || ratioB > 1) return;\r\n\r\n    const intersection = useObject(intersectionPool);\r\n    usedIntersections.push(intersection);\r\n    intersection.roadA = roadA;\r\n    intersection.positionRatioA = ratioA;\r\n    intersection.roadB = roadB;\r\n    intersection.positionRatioB = ratioB;\r\n\r\n    roadA.intersectionList.push(intersection);\r\n    roadB.intersectionList.push(intersection);\r\n  }\r\n\r\n  function recycleAllIntersections(): void {\r\n    const len = usedIntersections.length;\r\n    for (let i = 0; i < len; i++) {\r\n      recycleObject(intersectionPool, usedIntersections.pop());\r\n    }\r\n  }\r\n\r\n  function tryChangeRoad(\r\n    vehicle: Vehicle,\r\n    intersection: Intersection\r\n  ): boolean {\r\n    const currentRoad = vehicle.road;\r\n    let otherRoad: Road;\r\n    let currentRoadIntersectionPositionRatio: number;\r\n    let otherRoadIntersectionPositionRatio: number;\r\n    if (intersection.roadA === currentRoad) {\r\n      otherRoad = intersection.roadB;\r\n      currentRoadIntersectionPositionRatio = intersection.positionRatioA;\r\n      otherRoadIntersectionPositionRatio = intersection.positionRatioB;\r\n    } else {\r\n      otherRoad = intersection.roadA;\r\n      currentRoadIntersectionPositionRatio = intersection.positionRatioB;\r\n      otherRoadIntersectionPositionRatio = intersection.positionRatioA;\r\n    }\r\n\r\n    const ratioDifference =\r\n      vehicle.positionRatio - currentRoadIntersectionPositionRatio;\r\n\r\n    if (\r\n      ratioDifference < -POSITION_RATIO_DISTANCE_THREASHOLD ||\r\n      ratioDifference > POSITION_RATIO_DISTANCE_THREASHOLD\r\n    ) {\r\n      return false;\r\n    }\r\n\r\n    if (Math.random() >= ROAD_CHANGE_POSSIBILITY) {\r\n      vehicle.positionRatio =\r\n        currentRoadIntersectionPositionRatio +\r\n        POSITION_RATIO_DISTANCE_THREASHOLD;\r\n      return false;\r\n    }\r\n\r\n    vehicle.road = otherRoad;\r\n    vehicle.positionRatio =\r\n      otherRoadIntersectionPositionRatio + POSITION_RATIO_DISTANCE_THREASHOLD;\r\n    vehicle.roadChangeEffectTimer.resetCount().on();\r\n    return true;\r\n  }\r\n\r\n  function updateVehicle(vehicle: Vehicle): void {\r\n    if (Math.random() < VEHICLE_ACCELERATION_CHANGE_PROBABILITY)\r\n      vehicle.acceleration = randomIn(VEHICLE_ACCELERATION_RANGE);\r\n\r\n    let changeRate = constrainInRange(\r\n      vehicle.positionRatioChangeRate + vehicle.acceleration,\r\n      VEHICLE_POSITION_CHANGE_RATE_RANGE\r\n    );\r\n    vehicle.positionRatioChangeRate = changeRate;\r\n    vehicle.positionRatioTotalChange += changeRate;\r\n\r\n    let ratio = vehicle.positionRatio;\r\n    ratio += changeRate;\r\n    if (ratio > 1) ratio -= 1;\r\n\r\n    vehicle.positionRatio = ratio;\r\n\r\n    for (const intersection of vehicle.road.intersectionList) {\r\n      if (tryChangeRoad(vehicle, intersection)) return;\r\n    }\r\n\r\n    vehicle.roadChangeEffectTimer.step();\r\n  }\r\n\r\n  function drawVehicle(vehicle: Vehicle): void {\r\n    const road = vehicle.road;\r\n    const startPosition = road.startPoint.position;\r\n    const endPosition = road.endPoint.position;\r\n    const ratio = vehicle.positionRatio;\r\n    const expandFactor =\r\n      VEHICLE_EXPAND_MAX_RATIO *\r\n      Math.cos(VEHICLE_EXPAND_TIME_SCALE * vehicle.positionRatioTotalChange);\r\n    const diameter = (1 + expandFactor) * VEHICLE_SIZE;\r\n\r\n    const timer = vehicle.roadChangeEffectTimer;\r\n    const alphaRatio = timer.getProgressRatio();\r\n    if (timer.isOn && alphaRatio < 1) {\r\n      vehicleColor.applyColor(alphaRatio * 255);\r\n      drawCircleOnLineSegment(startPosition, endPosition, ratio, diameter);\r\n      activeVehicleColor.applyColor((1 - alphaRatio) * 255);\r\n      drawCircleOnLineSegment(startPosition, endPosition, ratio, diameter);\r\n    } else {\r\n      vehicleColor.applyColor();\r\n      drawCircleOnLineSegment(startPosition, endPosition, ratio, diameter);\r\n    }\r\n  }\r\n\r\n  function initialize() {\r\n    roads = new p5ex.LoopableArray(ROAD_COUNT);\r\n    for (let i = 0; i < ROAD_COUNT; i++) {\r\n      roads.push(createRoad());\r\n    }\r\n    vehicles = new p5ex.LoopableArray(VEHICLE_COUNT);\r\n    const roadArray = roads.array;\r\n    function createVehicle(): Vehicle {\r\n      return {\r\n        road: p.random(roadArray),\r\n        positionRatio: Math.random(),\r\n        positionRatioChangeRate: randomIn(VEHICLE_POSITION_CHANGE_RATE_RANGE),\r\n        positionRatioTotalChange: 0,\r\n        acceleration: 0,\r\n        roadChangeEffectTimer: new p5ex.NonLoopedFrameCounter(\r\n          ROAD_CHANGE_EFFECT_DURATION\r\n        ).off()\r\n      };\r\n    }\r\n    for (let i = 0; i < VEHICLE_COUNT; i++) {\r\n      vehicles.push(createVehicle());\r\n    }\r\n\r\n    const dummyRoad = createRoad();\r\n    intersectionPool = createObjectPool((): Intersection => {\r\n      return {\r\n        roadA: dummyRoad,\r\n        positionRatioA: 0,\r\n        roadB: dummyRoad,\r\n        positionRatioB: 0\r\n      };\r\n    }, MAX_INTERSECTION_COUNT);\r\n    usedIntersections = new p5ex.LoopableArray(MAX_INTERSECTION_COUNT);\r\n  }\r\n\r\n  // ---- Setup & Draw etc.\r\n  p.preload = () => {};\r\n\r\n  p.setup = () => {\r\n    p.createScalableCanvas(p5ex.ScalableCanvasTypes.FULL);\r\n    const backgroundGraphics = createGradationRectangle(\r\n      p,\r\n      p.nonScaledWidth,\r\n      p.nonScaledHeight,\r\n      p.color(254, 254, 255),\r\n      p.color(254, 254, 255),\r\n      p.color(244, 244, 255),\r\n      4,\r\n      2\r\n    ) as any;\r\n    p.scalableCanvas.scale();\r\n    p.image(backgroundGraphics, 0, 0);\r\n    p.scalableCanvas.cancelScale();\r\n    p.loadPixels();\r\n    backgroundPixels = p.pixels;\r\n    p.noFill();\r\n\r\n    roadColor = new p5ex.ShapeColor(p, p.color(128), undefined, false);\r\n    vehicleColor = new p5ex.ShapeColor(\r\n      p,\r\n      p.color(0, 112, 255),\r\n      // p.color(0, 112, 255, 32),\r\n      undefined,\r\n      true\r\n    );\r\n    activeVehicleColor = new p5ex.ShapeColor(\r\n      p,\r\n      p.color(240, 0, 128),\r\n      // p.color(240, 0, 128, 32),\r\n      undefined,\r\n      true\r\n    );\r\n\r\n    initialize();\r\n  };\r\n\r\n  p.draw = () => {\r\n    p.pixels = backgroundPixels;\r\n    p.updatePixels();\r\n\r\n    roads.loop(updateRoad);\r\n\r\n    roads.loop(clearIntersections);\r\n    recycleAllIntersections();\r\n    roads.roundRobin(tryAddIntersection);\r\n    vehicles.loop(updateVehicle);\r\n\r\n    roadColor.applyColor();\r\n    p.strokeWeight(ROAD_STROKE_WEIGHT);\r\n    roads.loop(drawRoad);\r\n    if (DRAW_INTERSECTIONS) usedIntersections.loop(drawIntersection);\r\n    p.strokeWeight(VEHICLE_STROKE_WEIGHT);\r\n    vehicles.loop(drawVehicle);\r\n  };\r\n\r\n  p.mousePressed = () => {\r\n    initialize();\r\n  };\r\n\r\n  p.keyTyped = () => {\r\n    if (p.key === \"p\") p.noLoop();\r\n\r\n    // if (p.key === \"s\") p.save(\"image.png\");\r\n  };\r\n};\r\n\r\nnew p5ex.p5exClass(sketch, SKETCH_NAME);\r\n"],"names":["p5ex.LoopableArray","p5ex.NonLoopedFrameCounter","p5ex.ScalableCanvasTypes","p5ex.ShapeColor","p5ex.p5exClass"],"mappings":"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"}