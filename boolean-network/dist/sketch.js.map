{"version":3,"file":"sketch.js","sources":["../node_modules/p5ex/lib/p5ex.mjs","../src/main.ts"],"sourcesContent":["/**\n* An extension of p5.js.\n* Including module: no-more-for-loops (Copyright 2018 FAL, licensed under MIT).\n* GitHub repository: {@link https://github.com/fal-works/p5ex}\n* @module p5ex\n* @copyright 2018 FAL\n* @author FAL <falworks.contact@gmail.com>\n* @license MIT\n* @version 0.5.3\n*/\n\n/**\n * Spatial region.\n */\nclass Region {\n}\n/**\n * Rectangle-shaped spatial region.\n */\nclass RectangleRegion extends Region {\n    get width() { return this.rightPositionX - this.leftPositionX; }\n    get height() { return this.bottomPositionY - this.topPositionY; }\n    get area() { return this.width * this.height; }\n    constructor(x1, y1, x2, y2, margin = 0) {\n        super();\n        this.leftPositionX = x1 - margin;\n        this.topPositionY = y1 - margin;\n        this.rightPositionX = x2 + margin;\n        this.bottomPositionY = y2 + margin;\n    }\n    contains(position, margin = 0) {\n        return (position.x >= this.leftPositionX - margin && position.x <= this.rightPositionX + margin &&\n            position.y >= this.topPositionY - margin && position.y <= this.bottomPositionY + margin);\n    }\n    constrain(position, margin = 0) {\n        if (position.x < this.leftPositionX - margin)\n            position.x = this.leftPositionX - margin;\n        else if (position.x > this.rightPositionX + margin)\n            position.x = this.rightPositionX + margin;\n        if (position.y < this.topPositionY - margin)\n            position.y = this.topPositionY - margin;\n        else if (position.y > this.bottomPositionY + margin)\n            position.y = this.bottomPositionY + margin;\n    }\n}\n// default region -> add\n\n/**\n * (To be filled)\n * @hideConstructor\n */\nclass ScalableCanvas {\n    constructor(p5Instance, parameter, node, rendererType) {\n        this.p = p5Instance;\n        this.canvasElement = p5Instance.createCanvas(parameter.scaledWidth, parameter.scaledHeight, rendererType);\n        if (this.canvasElement && 'parent' in this.canvasElement) {\n            this.canvasElement.parent(node);\n        }\n        this.region = new RectangleRegion(0, 0, 0, 0);\n        this.nonScaledShortSideLength = parameter.nonScaledShortSideLength;\n        this.updateSize();\n    }\n\n    /**\n     * (To be filled)\n     */\n    get scaleFactor() {\n        return this._scaleFactor;\n    }\n    /**\n     * (To be filled)\n     */\n    get nonScaledWidth() {\n        return this._nonScaledWidth;\n    }\n    /**\n     * (To be filled)\n     */\n    get nonScaledHeight() {\n        return this._nonScaledHeight;\n    }\n    /**\n     * (To be filled)\n     */\n    get aspectRatio() {\n        return this._aspectRatio;\n    }\n    /**\n     * (To be filled)\n     * @param parameter\n     */\n    resize(parameter) {\n        this.p.resizeCanvas(parameter.scaledWidth, parameter.scaledHeight);\n        this.nonScaledShortSideLength = parameter.nonScaledShortSideLength;\n        this.updateSize();\n    }\n    /**\n     * (To be filled)\n     */\n    updateSize() {\n        const p = this.p;\n        this._scaleFactor = Math.min(p.width, p.height) / this.nonScaledShortSideLength;\n        this._inversedScaleFactor = 1 / this._scaleFactor;\n        this._nonScaledWidth = p.width / this._scaleFactor;\n        this._nonScaledHeight = p.height / this._scaleFactor;\n        this._aspectRatio = p.width / p.height;\n        this.region.rightPositionX = this._nonScaledWidth;\n        this.region.bottomPositionY = this._nonScaledHeight;\n    }\n    /**\n     * Runs scale() of the current p5 instance for fitting the sketch to the current canvas.\n     * Should be called every frame before drawing objects on the canvas.\n     */\n    scale() {\n        this.p.scale(this._scaleFactor);\n    }\n    /**\n     * Runs scale() with the inversed scale factor.\n     */\n    cancelScale() {\n        this.p.scale(this._inversedScaleFactor);\n    }\n    /**\n     * Converts a length value on the scaled canvas to the non-scaled one.\n     * Typically used for interpreting mouseX and mouseY.\n     * @param {number} scaledLength - scaled length value\n     */\n    getNonScaledValueOf(scaledLength) {\n        return scaledLength / this._scaleFactor;\n    }\n}\nScalableCanvas.DUMMY_PARAMETERS = {\n    scaledWidth: 100,\n    scaledHeight: 100,\n    nonScaledShortSideLength: 100,\n};\n\n/**\n * (To be filled)\n * (This is not implemented as an enum because it is not supported by rollup)\n */\nconst ScalableCanvasTypes = {\n    SQUARE640x640: 'SQUARE640x640',\n    RECT640x480: 'RECT640x480',\n    FULL: 'FULL',\n    CUSTOM: 'CUSTOM',\n};\n\nclass NormalColorUnit {\n    constructor(p, p5Color) {\n        this.p = p;\n        this.p5Color = p5Color;\n    }\n    stroke() {\n        this.p.currentRenderer.stroke(this.p5Color);\n    }\n    fill() {\n        this.p.currentRenderer.fill(this.p5Color);\n    }\n}\nclass NoColorUnit {\n    constructor(p) {\n        this.p = p;\n    }\n    stroke() {\n        this.p.currentRenderer.noStroke();\n    }\n    fill() {\n        this.p.currentRenderer.noFill();\n    }\n}\nclass UndefinedColorUnit {\n    stroke() {\n    }\n    fill() {\n    }\n}\nclass AlphaColorUnit {\n    constructor(p, c, alphaResolution = 256) {\n        this.p = p;\n        const array = [];\n        for (let alphaFactor = 0; alphaFactor < alphaResolution; alphaFactor += 1) {\n            array.push(p.color(p.red(c), p.green(c), p.blue(c), p.alpha(c) * alphaFactor / (alphaResolution - 1)));\n        }\n        this.colorArray = array;\n        this.maxIndex = alphaResolution - 1;\n    }\n    stroke(alphaValue) {\n        this.p.currentRenderer.stroke(this.getColor(alphaValue));\n    }\n    fill(alphaValue) {\n        this.p.currentRenderer.fill(this.getColor(alphaValue));\n    }\n    getColor(alphaValue) {\n        return this.colorArray[alphaValue ? Math.floor(this.p.map(alphaValue, 0, 255, 0, this.maxIndex)) : this.maxIndex];\n    }\n}\nfunction colorUnit(p, p5Color, alphaEnabled, alphaResolution) {\n    if (!p || p5Color === undefined)\n        return new UndefinedColorUnit();\n    if (p5Color === null)\n        return new NoColorUnit(p);\n    if (alphaEnabled)\n        return new AlphaColorUnit(p, p5Color, alphaResolution);\n    return new NormalColorUnit(p, p5Color);\n}\n/**\n * Composition of two p5.Color instances. One for stroke(), one for fill().\n */\nclass ShapeColor {\n    /**\n     *\n     * @param p - p5ex instance.\n     * @param {p5.Color | null | undefined} strokeColor - Color for stroke(). Null means noStroke().\n     * @param {p5.Color | null | undefined} fillColor - Color for fill(). Null means noFill().\n     * @param {boolean} [alphaEnabled]\n     * @param {number} [alphaResolution]\n     */\n    constructor(p, strokeColor, fillColor, alphaEnabled, alphaResolution) {\n        this.strokeColor = colorUnit(p, strokeColor, alphaEnabled, alphaResolution);\n        this.fillColor = colorUnit(p, fillColor, alphaEnabled, alphaResolution);\n    }\n    /**\n     * Applies colors to the current p5 renderer.\n     * @param {number} alphaValue - Alpha channel value (0 - 255)\n     */\n    applyColor(alphaValue) {\n        this.strokeColor.stroke(alphaValue);\n        this.fillColor.fill(alphaValue);\n    }\n}\n/**\n * Undefined object of p5ex.ShapeColor.\n * @static\n */\nShapeColor.UNDEFINED = new ShapeColor(undefined, undefined, undefined);\n\n/**\n * An empty function.\n */\nconst EMPTY_FUNCTION = () => { };\n/**\n * 1.5 * PI\n */\nconst ONE_AND_HALF_PI = 1.5 * Math.PI;\n\nconst dummyP5 = new p5((p) => {\n    p.setup = () => {\n        p.noCanvas();\n    };\n});\n\n/**\n * Calculates the squared value of the Euclidean distance between\n * two points (considering a point as a vector object).\n */\nfunction distSq(v1, v2) {\n    return Math.pow(v2.x - v1.x, 2) + Math.pow(v2.y - v1.y, 2) + Math.pow(v2.z - v1.z, 2);\n}\n/**\n * Multiplies the given matrix and array.\n * The number of matrix columns and the array length must be identical.\n * @param {number[][]} matrix - Any matrix.\n * @param {number[]} array - Any one-dimensional array of numbers.\n * @param {number[]} [target] - Target array for receiving the result.\n * @returns Product of the given values as an array.\n */\nfunction multiplyMatrixAndArray(matrix, array, target) {\n    const matrixRowCount = matrix.length;\n    const matrixColumnCount = matrix[0].length;\n\n    const resultArray = target || new Array(matrixRowCount);\n\n    for (let row = 0; row < matrixRowCount; row += 1) {\n        resultArray[row] = 0;\n        for (let col = 0; col < matrixColumnCount; col += 1) {\n            resultArray[row] += matrix[row][col] * array[col];\n        }\n    }\n    return resultArray;\n}\nconst TWO_PI = 2 * Math.PI;\n/**\n * Calculates the difference between two angles in range of -PI to PI.\n * @param angleA - the angle to subtract from\n * @param angleB - the angle to subtract\n */\nfunction angleDifference(angleA, angleB) {\n    let diff = (angleA - angleB) % TWO_PI;\n    if (diff < -Math.PI)\n        diff += TWO_PI;\n    else if (diff > Math.PI)\n        diff -= TWO_PI;\n    return diff;\n}\n/**\n * Calculates the direction angle from one vector to another.\n * @param referencePosition\n * @param targetPosition\n */\nfunction getDirectionAngle(referencePosition, targetPosition) {\n    return Math.atan2(targetPosition.y - referencePosition.y, targetPosition.x - referencePosition.x);\n}\n// Temporal vectors for calculation use in getClosestPositionOnLineSegment()\nconst tmpVectorAP = dummyP5.createVector();\nconst tmpVectorAB = dummyP5.createVector();\n/**\n * Returns the position on the line segment AB which is closest to the reference point P.\n * @param {p5.Vector} P - The position of the reference point.\n * @param {p5.Vector} A - The position of the line segment start point.\n * @param {p5.Vector} B - The position of the line segment end point.\n * @param {p5.Vector} target - The vector to receive the result.\n */\n\n/**\n * Just lerp.\n * @param startValue - The start value.\n * @param endValue - The end value.\n * @param ratio - The ratio between 0 and 1.\n */\nfunction lerp(startValue, endValue, ratio) {\n    return startValue + ratio * (endValue - startValue);\n}\n\n/**\n * Returns random value from the min number up to (but not including) the max number.\n */\nfunction randomBetween(min, max) {\n    return min + Math.random() * (max - min);\n}\n/**\n * Returns random integer from 0 up to (but not including) the max number.\n */\nfunction randomInt(maxInt) {\n    return Math.floor(Math.random() * maxInt);\n}\n/**\n * Returns random integer from the min number up to (but not including) the max number.\n */\nfunction randomIntBetween(minInt, maxInt) {\n    return minInt + randomInt(maxInt - minInt);\n}\n/**\n * Returns one of array elements randomly.\n * @param array\n */\nfunction getRandom(array) {\n    return array[randomInt(array.length)];\n}\n/**\n * Returns n or -n randomly. (n = provided number)\n * @param {number} n - any number\n */\nfunction randomSign(n) {\n    if (Math.random() < 0.5)\n        return n;\n    return -n;\n}\n/**\n * Returns and removes one array element randomly.\n * @param array\n */\nfunction popRandom(array) {\n    return array.splice(randomInt(array.length), 1)[0];\n}\n\n/**\n * Container class of number.\n */\nclass NumberContainer {\n    /**\n     * @constructor\n     * @param {number} value\n     */\n    constructor(value = 0) {\n        this.value = value;\n    }\n    valueOf() {\n        return this.value;\n    }\n}\n/**\n * Null object of NumberContainer.\n * @static\n */\nNumberContainer.NULL = new NumberContainer();\n\n/**\n * (To be filled)\n */\nclass WeightedRandomSelector {\n    constructor() {\n        this.candidateList = [];\n        this.candidateCount = 0;\n        this.totalProbabiligyWeight = 0;\n    }\n    /**\n     * Adds one element with provided weight of probability.\n     * @param element\n     * @param probabilityWeight\n     * @chainable\n     */\n    push(element, probabilityWeight) {\n        this.candidateList.push({\n            element,\n            threshold: this.totalProbabiligyWeight + probabilityWeight,\n        });\n        this.candidateCount += 1;\n        this.totalProbabiligyWeight += probabilityWeight;\n        return this;\n    }\n    /**\n     * Clears all elements.\n     * @chainable\n     */\n    clear() {\n        this.candidateList.length = 0;\n        this.candidateCount = 0;\n        this.totalProbabiligyWeight = 0;\n        return this;\n    }\n    /**\n     * Returns one element randomly.\n     * The probability for each element is:\n     * (probability weight of the element) / (total probability weight)\n     */\n    get() {\n        const rnd = Math.random() * this.totalProbabiligyWeight;\n        for (let i = 0; i < this.candidateCount; i += 1) {\n            if (rnd < this.candidateList[i].threshold)\n                return this.candidateList[i].element;\n        }\n        return this.candidateList[this.candidateCount - 1].element; // unreachable\n    }\n}\n\n/**\n * Linear easing function.\n * @param ratio\n */\nfunction easeLinear(ratio) {\n    return ratio;\n}\n/**\n * easeOutQuad.\n * @param ratio\n */\nfunction easeOutQuad(ratio) {\n    return -Math.pow(ratio - 1, 2) + 1;\n}\n/**\n * easeOutCubic.\n * @param ratio\n */\nfunction easeOutCubic(ratio) {\n    return Math.pow(ratio - 1, 3) + 1;\n}\n/**\n * easeOutQuart.\n * @param ratio\n */\nfunction easeOutQuart(ratio) {\n    return -Math.pow(ratio - 1, 4) + 1;\n}\nconst EASE_OUT_BACK_DEFAULT_COEFFICIENT = 1.70158;\n/**\n * easeOutBack.\n * @param ratio\n */\nfunction easeOutBack(ratio) {\n    const r = ratio - 1;\n    return ((EASE_OUT_BACK_DEFAULT_COEFFICIENT + 1) * Math.pow(r, 3)\n        + EASE_OUT_BACK_DEFAULT_COEFFICIENT * Math.pow(r, 2) + 1);\n}\n/**\n * Returns an easeOut function.\n * @param exponent - Integer from 1 to 4.\n */\nfunction getEasingFunction(exponent) {\n    switch (Math.floor(exponent)) {\n        default:\n        case 1:\n            return easeLinear;\n        case 2:\n            return easeOutQuad;\n        case 3:\n            return easeOutCubic;\n        case 4:\n            return easeOutQuart;\n    }\n}\n\n/**\n * (To be filled)\n */\nclass RandomShapeColor {\n    constructor() {\n        this.candidateArray = [];\n    }\n    /**\n     * (To be filled)\n     * @param createShapeColor - Any function which returns a p5ex.ShapeColor instance.\n     * @param {number} candidateCount - Number of color candidates to push.\n     */\n    pushCandidateFromFunction(createShapeColor, candidateCount) {\n        for (let i = 0; i < candidateCount; i += 1) {\n            this.candidateArray.push(createShapeColor());\n        }\n        return this;\n    }\n    /**\n     * (To be filled)\n     * @param {p5.Color} shapeColor - Any p5.Color instance.\n     * @param {number} candidateCount - Number of color candidates to push.\n     */\n    pushCandidate(shapeColor, candidateCount = 1) {\n        for (let i = 0; i < candidateCount; i += 1) {\n            this.candidateArray.push(shapeColor);\n        }\n        return this;\n    }\n    /**\n     * Clears all color candidates.\n     */\n    clear() {\n        this.candidateArray.length = 0;\n        return this;\n    }\n    /**\n     * Returns one of color candidates randomly.\n     */\n    get() {\n        return getRandom(this.candidateArray);\n    }\n}\n\nfunction createCielabToXyzFunc() {\n    const delta = 6 / 29;\n    const constantA = 16 / 116;\n    const constantB = 3 * delta * delta;\n    return (value) => {\n        if (value > delta)\n            return value * value * value;\n        return (value - constantA) * constantB;\n    };\n}\nconst cielabToXyzFunc = createCielabToXyzFunc();\n/**\n * Converts color values from CIELAB (D65) to XYZ.\n * @param {number[]} cielabValue - Value array of L*, a*, b* (D65).\n * @param {Illuminant} illuminant - Instance of Illuminant.\n * @param {number[]} [target] - Target array for receiving the result.\n * @returns {number[]} XYZ value array.\n */\nfunction cielabValueToXyzValue(cielabValue, illuminant, target) {\n    const yFactor = (cielabValue[0] + 16.0) / 116.0;\n    const xFactor = yFactor + cielabValue[1] / 500.0;\n    const zFactor = yFactor - cielabValue[2] / 200.0;\n    if (target) {\n        target[0] = illuminant.tristimulusValues[0] * cielabToXyzFunc(xFactor);\n        target[1] = illuminant.tristimulusValues[1] * cielabToXyzFunc(yFactor);\n        target[2] = illuminant.tristimulusValues[2] * cielabToXyzFunc(zFactor);\n        return target;\n    }\n    return [\n        illuminant.tristimulusValues[0] * cielabToXyzFunc(xFactor),\n        illuminant.tristimulusValues[1] * cielabToXyzFunc(yFactor),\n        illuminant.tristimulusValues[2] * cielabToXyzFunc(zFactor),\n    ];\n}\n\n/**\n * Matrix for conversion color values from XYZ to linear RGB.\n * Values from \"7. Conversion from XYZ (D65) to linear sRGB values\" in\n * http://www.color.org/chardata/rgb/sRGB.pdf (April 2015)\n * @constant {number[][]} xyzToLinearRgbConversionMatrix\n * @ignore\n */\nconst xyzToLinearRgbConversionMatrix = [\n    [3.2406255, -1.537208, -0.4986286],\n    [-0.9689307, 1.8757561, 0.0415175],\n    [0.0557101, -0.2040211, 1.0569959],\n];\n/**\n * Matrix for converting color values from linear RGB to XYZ.\n * This is an inversed matrix of xyzToLinearRgbConversionMatrix\n * which is pre-calculated by math.js.\n * @constant {number[][]} linearRgbToXyzConversionMatrix\n * @ignore\n */\n\n/**\n * CIE standard illuminant.\n */\nclass Illuminant {\n    constructor(name, tristimulusValues) {\n        this.name = name;\n        this.tristimulusValues = tristimulusValues;\n    }\n}\n\n/**\n * Map of illuminants.\n */\nconst Illuminants = {\n    D50: new Illuminant('D50', [0.9642, 1.0000, 0.8251]),\n    D55: new Illuminant('D55', [0.9568, 1.0000, 0.9214]),\n    D65: new Illuminant('D65', [0.95047, 1.00000, 1.08883]),\n    E: new Illuminant('E', [1, 1, 1]),\n};\n\n/**\n * Applies display gamma correction to the given number.\n * @param value - any number in a linear color space (0 - 1).\n * @ignore\n */\nfunction degamma(value) {\n    if (value <= 0.0031308)\n        return 12.92 * value;\n    return 1.055 * Math.pow(value, 1.0 / 2.4) - 0.055;\n}\n/**\n * Returns the difference of two colors. The alpha values of the original colors will be ignored.\n * @param {p5.Color} c1 - The color to subtract from\n * @param {p5.Color} c2 - The color to subtract\n * @param {number} [alphaValue] - Alpha value of the result color\n */\nfunction subtractColor(c1, c2, alphaValue) {\n    return dummyP5.color(dummyP5.red(c1) - dummyP5.red(c2), dummyP5.green(c1) - dummyP5.green(c2), dummyP5.blue(c1) - dummyP5.blue(c2), alphaValue);\n}\n/**\n * Creates a new p5.Color instance in HSB color mode and\n * immediately reset the color mode to default.\n * @param {number} h - Hue (0 - 360)\n * @param {number} s - Saturation (0 - 100)\n * @param {number} b - Brightness (0 - 100)\n * @param {number} [a] - Alpha (0 - 255)\n */\nfunction hsbColor(h, s, b, a) {\n    dummyP5.colorMode(dummyP5.HSB, 360, 100, 100, 255);\n    const c = dummyP5.color(h, s, b);\n    dummyP5.colorMode(dummyP5.RGB, 1, 1, 1, 255);\n    const gammaCorrectedColor = dummyP5.color(degamma(dummyP5.red(c)), degamma(dummyP5.green(c)), degamma(dummyP5.blue(c)), a);\n    dummyP5.colorMode(dummyP5.RGB, 255, 255, 255, 255);\n    return gammaCorrectedColor;\n}\n\nlet currentIlluminant = Illuminants.D50;\n/**\n * Sets the current illuminant. (e.g. D50, D65 etc.)\n * @param illuminant - Any Illuminant.\n * @example setIlluminant(Illuminants.D65);\n */\nfunction setIlluminant(illuminant) {\n    currentIlluminant = illuminant;\n}\nconst temporalArray1 = [0, 0, 0];\nconst temporalArray2 = [0, 0, 0];\nconst temporalArray3 = [0, 0, 0];\nconst temporalArray4 = [0, 0, 0];\nfunction assignArray(array, v0, v1, v2) {\n    array[0] = v0;\n    array[1] = v1;\n    array[2] = v2;\n    return array;\n}\n/**\n * Clips the given linear RGB factor to the valid range (0 - 1)\n * and converts it to an sRGB value (0 - 255).\n * @param factor - Factor of either red, green or blue in the linear RGB color space.\n * @returns sRGB value.\n * @ignore\n */\nfunction linearRgbFactorToSrgbValue(factor) {\n    return degamma(Math.min(Math.max(factor, 0), 1)) * 255;\n}\n/**\n * Converts CIELAB values to an array of RGB values (0 - 255).\n * @param {number} lValue - L*: Lightness (0 - 100)\n * @param {number} aValue - a* (0 - ca. 100)\n * @param {number} bValue - b* (0 - ca. 100)\n * @param {number} [alphaValue] - Alhpa value (0 - 255)\n * @returns New Array of sRGB values.\n */\nfunction cielabColor(lValue, aValue, bValue, alphaValue) {\n    const labValue = assignArray(temporalArray1, lValue, aValue, bValue);\n    const xyzValue = cielabValueToXyzValue(labValue, currentIlluminant, temporalArray2);\n    const rgbFactor = multiplyMatrixAndArray(xyzToLinearRgbConversionMatrix, xyzValue, temporalArray3);\n    const srgbValue = assignArray(temporalArray4, linearRgbFactorToSrgbValue(rgbFactor[0]), linearRgbFactorToSrgbValue(rgbFactor[1]), linearRgbFactorToSrgbValue(rgbFactor[2]));\n    return alphaValue ? [\n        srgbValue[0],\n        srgbValue[1],\n        srgbValue[2],\n        alphaValue,\n    ] : [\n        srgbValue[0],\n        srgbValue[1],\n        srgbValue[2],\n    ];\n}\n/**\n * Converts CIELCh values to an array of RGB values (0 - 255).\n * @param {number} lValue - L*: Lightness (0 - 100)\n * @param {number} cValue - C*: Chroma (0 - ca. 100)\n * @param {number} hValue - h*: Hue (0 - 2PI)\n * @param {number} [alphaValue] - Alhpa value (0 - 255)\n */\nfunction cielchColor(lValue, cValue, hValue, alphaValue) {\n    return cielabColor(lValue, cValue * Math.cos(hValue), cValue * Math.sin(hValue), alphaValue);\n}\n\n/**\n * (To be filled)\n */\nclass ScreenEffect {\n    constructor(p) {\n        this.p = p;\n    }\n}\n/**\n * (To be filled)\n */\nclass ScreenShake extends ScreenEffect {\n    constructor(p, dampingRatio = 0.95) {\n        super(p);\n        this.dampingRatio = dampingRatio;\n        this.amplitude = 0;\n        this.offsetX = 0;\n        this.offsetY = 0;\n    }\n    apply() {\n        if (this.amplitude === 0)\n            return;\n        this.offsetX = Math.random() * this.amplitude;\n        this.offsetY = Math.random() * this.amplitude;\n        this.p.currentRenderer.translate(this.offsetX, this.offsetY);\n        this.amplitude = this.amplitude * this.dampingRatio;\n        if (this.amplitude < 1)\n            this.amplitude = 0;\n    }\n    set(amplitude) {\n        this.amplitude = Math.max(this.amplitude, amplitude);\n    }\n    reset() {\n        this.amplitude = 0;\n    }\n    cancel() {\n        this.p.currentRenderer.translate(-this.offsetX, -this.offsetY);\n    }\n}\n/**\n * (To be filled)\n */\nclass ScreenFlash extends ScreenEffect {\n    constructor(p, flashColor = p.color(255)) {\n        super(p);\n        this.alphaValue = 0;\n        this.valueChange = 0;\n        this.flashColor = new ShapeColor(p, null, flashColor, true);\n    }\n    apply() {\n        if (this.alphaValue === 0)\n            return;\n        this.flashColor.applyColor(this.alphaValue);\n        this.p.currentRenderer.rect(0, 0, this.p.scalableCanvas.nonScaledWidth, this.p.scalableCanvas.nonScaledHeight);\n        this.alphaValue -= this.valueChange;\n        if (this.alphaValue < 1)\n            this.alphaValue = 0;\n    }\n    set(initialAlphaValue, durationSeconds) {\n        this.alphaValue = initialAlphaValue;\n        this.valueChange = initialAlphaValue / (durationSeconds * this.p.idealFrameRate);\n    }\n    reset() {\n        this.alphaValue = 0;\n    }\n}\n\n/**\n * (To be filled)\n */\nclass AlphaBackground {\n    /**\n     *\n     * @param p5exInstance\n     * @param backgroundColor\n     * @param drawIntervalFrameCount\n     * @param blendModeString\n     * @param defaultBlendModeString\n     */\n    constructor(p5exInstance, backgroundColor, drawIntervalFrameCount = 1, blendModeString, defaultBlendModeString) {\n        this.p = p5exInstance;\n        this.backgroundColor = backgroundColor;\n        this.drawIntervalFrameCount = drawIntervalFrameCount;\n        this.blendModeString = blendModeString;\n        this.defaultBlendModeString = defaultBlendModeString;\n    }\n    /**\n     * Draws the background.\n     */\n    draw() {\n        if (this.p.frameCount % this.drawIntervalFrameCount !== 0)\n            return;\n        if (this.blendModeString)\n            this.p.blendMode(this.blendModeString);\n        this.p.noStroke();\n        this.p.fill(this.backgroundColor);\n        this.p.rect(0, 0, this.p.width, this.p.height);\n        if (this.defaultBlendModeString)\n            this.p.blendMode(this.defaultBlendModeString);\n    }\n}\n\n/**\n * Returns true if the mouse is within the canvas.\n * @param p - The p5 instance.\n */\nfunction mouseIsInCanvas(p) {\n    if (p.mouseX < 0)\n        return false;\n    if (p.mouseX > p.width)\n        return false;\n    if (p.mouseY < 0)\n        return false;\n    if (p.mouseY > p.height)\n        return false;\n    return true;\n}\n\nfunction loopArrayLimited(array, callback, arrayLength) {\n    let i = 0;\n    while (i < arrayLength) {\n        callback(array[i], i, array);\n        i += 1;\n    }\n}\n/**\n * Executes a provided function once for each array element.\n * @param {Array} array\n * @param {loopArrayCallBack} callback\n */\nfunction loopArray(array, callback) {\n    loopArrayLimited(array, callback, array.length);\n}\nfunction loopArrayBackwardsLimited(array, callback, arrayLength) {\n\n    while (arrayLength--) {\n        callback(array[arrayLength], arrayLength, array);\n    }\n}\n/**\n * Executes a provided function once for each array element in descending order.\n * @param {Array} array\n * @param {loopArrayCallback} callback\n */\nfunction loopArrayBackwards(array, callback) {\n    loopArrayBackwardsLimited(array, callback, array.length);\n}\n/**\n * @callback loopArrayCallBack\n * @param {} currentValue\n * @param {number} [index]\n * @param {Array} [array]\n */\n\nfunction roundRobinLimited(array, callback, arrayLength) {\n    for (let i = 0, len = arrayLength - 1; i < len; i += 1) {\n        for (let k = i + 1; k < arrayLength; k += 1) {\n            callback(array[i], array[k]);\n        }\n    }\n}\n/**\n * Executes a provided function once for each pair within the array.\n * @param {Array} array\n * @param {roundRobinCallBack} callback\n */\nfunction roundRobin(array, callback) {\n    roundRobinLimited(array, callback, array.length);\n}\n/**\n * @callback roundRobinCallBack\n * @param {} element\n * @param {} otherElement\n */\n\nfunction nestedLoopJoinLimited(array, otherArray, callback, arrayLength, otherArrayLength) {\n    for (let i = 0; i < arrayLength; i += 1) {\n        for (let k = 0; k < otherArrayLength; k += 1) {\n            callback(array[i], otherArray[k]);\n        }\n    }\n}\n/**\n * Joins two arrays and executes a provided function once for each joined pair.\n * @param {Array} array\n * @param {Array} otherArray\n * @param {nestedLoopJoinCallBack} callback\n */\nfunction nestedLoopJoin(array, otherArray, callback) {\n    nestedLoopJoinLimited(array, otherArray, callback, array.length, otherArray.length);\n}\n/**\n * @callback nestedLoopJoinCallBack\n * @param {} element\n * @param {} otherElement\n */\n\n/**\n * A class containing an array and several loop methods.\n */\nclass LoopableArray {\n    /**\n     * @param {number} initialCapacity\n     */\n    constructor(initialCapacity = 256) {\n\n        this.array = new Array(initialCapacity);\n        this.length = 0;\n    }\n    /**\n     * Returns a specific element.\n     * It is recommended to check that you are going to specify a valid index number\n     * before calling this method.\n     * @returns The specified element.\n     */\n    get(index) {\n        return this.array[index];\n    }\n    /**\n     * Returns the last element.\n     * It is recommended to check that this array is not empty before calling this method.\n     * @returns The last element.\n     */\n    getLast() {\n        return this.array[this.length - 1];\n    }\n    /**\n     * Adds one element to the end of the array and returns the new length of the array.\n     * @param {} element - The element to add to the end of the array.\n     */\n    push(element) {\n        this.array[this.length] = element;\n        this.length += 1;\n        return this.length;\n    }\n    /**\n     * Adds elements to the end of the array and returns the new length of the array.\n     * @param {Array} array - The elements to add to the end of the array.\n     */\n    pushRawArray(array, arrayLength = array.length) {\n        for (let i = 0; i < arrayLength; i += 1) {\n            this.array[this.length + i] = array[i];\n        }\n        this.length += arrayLength;\n        return this.length;\n    }\n    /**\n     * Adds all elements from another LoopableArray and returns the new length of the array.\n     * @param {LoopableArray} otherLoopableArray\n     */\n    pushAll(otherLoopableArray) {\n        return this.pushRawArray(otherLoopableArray.array, otherLoopableArray.length);\n    }\n    /**\n     * Removes and returns the last element.\n     * It is recommended to check that this array is not empty before calling this method.\n     * @returns The last element.\n     */\n    pop() {\n        this.length -= 1;\n        return this.array[this.length];\n    }\n    /**\n     * Clears the array.\n     */\n    clear() {\n        this.length = 0;\n    }\n    /**\n     * @callback loopArrayCallBack\n     * @param {} currentValue\n     * @param {number} [index]\n     * @param {Array} [array]\n     */\n    /**\n     * Executes a provided function once for each array element.\n     * @param {loopArrayCallBack} callback\n     */\n    loop(callback) {\n        loopArrayLimited(this.array, callback, this.length);\n    }\n    /**\n     * Executes a provided function once for each array element in descending order.\n     * @param {loopArrayCallBack} callback\n     */\n    loopBackwards(callback) {\n        loopArrayBackwardsLimited(this.array, callback, this.length);\n    }\n    /**\n     * @callback elementPairCallBack\n     * @param {} element\n     * @param {} otherElement\n     */\n    /**\n     * Executes a provided function once for each pair within the array.\n     * @param {elementPairCallback} callback\n     */\n    roundRobin(callback) {\n        roundRobinLimited(this.array, callback, this.length);\n    }\n    /**\n     * Joins two arrays and executes a provided function once for each joined pair.\n     * @param {LoopableArray} otherArray\n     * @param {elementPairCallback} callback\n     */\n    nestedLoopJoin(otherArray, callback) {\n        nestedLoopJoinLimited(this.array, otherArray.array, callback, this.length, otherArray.length);\n    }\n}\n\n/**\n * (To be filled)\n */\nclass TwoDimensionalArray extends LoopableArray {\n    /**\n     * (To be filled)\n     * @param {number} xCount\n     * @param {number} yCount\n     * @param fillElement\n     */\n    constructor(xCount, yCount, fillElement) {\n        super(xCount * yCount);\n        this.xCount = xCount;\n        this.yCount = yCount;\n        if (fillElement) {\n            for (let i = 0, len = xCount * yCount; i < len; i += 1) {\n                this.push(fillElement);\n            }\n        }\n    }\n    /**\n     * Returns the specified element.\n     * @param x\n     * @param y\n     */\n    get2D(x, y) {\n        return this.array[x + this.xCount * y];\n    }\n    /**\n     * (To be filled)\n     * @param x\n     * @param y\n     * @param element\n     */\n    set2D(x, y, element) {\n        this.array[x + this.xCount * y] = element;\n    }\n}\n\n/**\n * A Naive implementation of an edge between two objects.\n */\nclass NaiveEdge {\n    /**\n     *\n     * @param nodeA\n     * @param nodeB\n     */\n    constructor(nodeA, nodeB) {\n        this.nodeA = nodeA;\n        this.nodeB = nodeB;\n    }\n    /**\n     * Returns true if the provided node is incident to this edge.\n     * @param node\n     */\n    isIncidentTo(node) {\n        return node === this.nodeA || node === this.nodeB;\n    }\n    /**\n     * Returns the adjacent node of the given node via this edge.\n     * If this edge is not incident to the given node, returns always the end point node.\n     * @param {T} node - any node which is incident to this edge\n     */\n    getAdjacentNode(node) {\n        if (node === this.nodeB)\n            return this.nodeA;\n        return this.nodeB;\n    }\n}\n\n/**\n * (To be filled)\n */\nclass NullCell {\n    getNeighborCell(relativeX, relativeY) {\n        return this;\n    }\n    setNeighborCell(relativeX, relativeY, cell) { }\n}\nconst NULL = new NullCell();\n/**\n * (To be filled)\n */\nclass NaiveCell {\n    /**\n     *\n     * @param neighborRange\n     */\n    constructor(neighborRange = 1) {\n        this.neighborCells = new TwoDimensionalArray(2 * neighborRange + 1, 2 * neighborRange + 1, NULL);\n    }\n    /**\n     * Returns the specified neighbor cell.\n     * @param {number} relativeX\n     * @param {number} relativeY\n     */\n    getNeighborCell(relativeX, relativeY) {\n        const neighborRange = Math.floor(this.neighborCells.xCount / 2);\n        if (relativeX < -neighborRange || relativeX > neighborRange ||\n            relativeY < -neighborRange || relativeY > neighborRange)\n            return NULL;\n        return this.neighborCells.get2D(relativeX + neighborRange, relativeY + neighborRange);\n    }\n    /**\n     * Sets the provided cell as a neighbor of this cell.\n     * @param relativeX\n     * @param relativeY\n     * @param cell\n     */\n    setNeighborCell(relativeX, relativeY, cell) {\n        const neighborRange = Math.floor(this.neighborCells.xCount / 2);\n        this.neighborCells.set2D(relativeX + neighborRange, relativeY + neighborRange, cell);\n    }\n}\n/**\n * (To be filled)\n */\nclass Grid {\n    /**\n     *\n     * @param {number} xCount\n     * @param {number} yCount\n     * @param {number} neighborRange\n     * @param {boolean} loopAtEndOfScreen\n     */\n    constructor(xCount, yCount, neighborRange, loopAtEndOfScreen, cellFactory, nullCell) {\n        this.nullCell = nullCell;\n        this.cell2DArray = new TwoDimensionalArray(xCount, yCount, nullCell);\n        this.cellIndexMap = new Map();\n        for (let yIndex = 0; yIndex < yCount; yIndex += 1) {\n            for (let xIndex = 0; xIndex < xCount; xIndex += 1) {\n                const cell = cellFactory(neighborRange);\n                this.cell2DArray.set2D(xIndex, yIndex, cell);\n                this.cellIndexMap.set(cell, { x: xIndex, y: yIndex });\n            }\n        }\n        this.cell2DArray.loop((cell) => {\n            this.setNeighborCells(cell, neighborRange, loopAtEndOfScreen);\n        });\n    }\n    /**\n     * Returns the specified cell.\n     * @param {number} x - X index.\n     * @param {number} y - Y index.\n     */\n    getCell(x, y) {\n        return this.cell2DArray.get2D(x, y);\n    }\n    /**\n     * Returns the x and y index of the given cell.\n     * @param cell\n     */\n    getCellIndex(cell) {\n        return this.cellIndexMap.get(cell) || { x: -1, y: -1 };\n    }\n    /**\n     * (To be filled)\n     * @param referenceCell\n     * @param {number} relX\n     * @param {number} relY\n     * @param {boolean} loopAtEndOfScreen\n     */\n    getRelativePositionCell(referenceCell, relX, relY, loopAtEndOfScreen) {\n        if (referenceCell === this.nullCell)\n            return referenceCell;\n        if (relX === 0 && relY === 0)\n            return referenceCell;\n        const referenceIndex = this.getCellIndex(referenceCell);\n        const targetIndex = {\n            x: referenceIndex.x + relX,\n            y: referenceIndex.y + relY,\n        };\n        if (loopAtEndOfScreen) {\n            if (targetIndex.x < 0)\n                targetIndex.x += this.cell2DArray.xCount;\n            else if (targetIndex.x >= this.cell2DArray.xCount)\n                targetIndex.x -= this.cell2DArray.xCount;\n            if (targetIndex.y < 0)\n                targetIndex.y += this.cell2DArray.yCount;\n            else if (targetIndex.y >= this.cell2DArray.yCount)\n                targetIndex.y -= this.cell2DArray.yCount;\n        }\n        else {\n            if (targetIndex.x < 0 || targetIndex.x >= this.cell2DArray.xCount ||\n                targetIndex.y < 0 || targetIndex.y >= this.cell2DArray.yCount)\n                return this.nullCell;\n        }\n        return this.cell2DArray.get2D(targetIndex.x, targetIndex.y);\n    }\n    setNeighborCells(referenceCell, neighborRange, loopAtEndOfScreen) {\n        for (let relativeX = -neighborRange; relativeX <= neighborRange; relativeX += 1) {\n            for (let relativeY = -neighborRange; relativeY <= neighborRange; relativeY += 1) {\n                referenceCell.setNeighborCell(relativeX, relativeY, this.getRelativePositionCell(referenceCell, relativeX, relativeY, loopAtEndOfScreen));\n            }\n        }\n    }\n}\n\n/**\n * (To be filled)\n */\nclass DrawableArray extends LoopableArray {\n    static drawFunction(value) {\n        value.draw();\n    }\n    /**\n     * Draws all child elements.\n     */\n    draw() {\n        this.loop(DrawableArray.drawFunction);\n    }\n}\n\n/**\n * (To be filled)\n */\nclass SteppableArray extends LoopableArray {\n    static stepFunction(value) {\n        value.step();\n    }\n    /**\n     * Steps all child elements.\n     */\n    step() {\n        this.loop(SteppableArray.stepFunction);\n    }\n}\n\n/**\n * (To be filled)\n */\nclass SpriteArray extends LoopableArray {\n}\nSpriteArray.prototype.step = SteppableArray.prototype.step;\nSpriteArray.prototype.draw = DrawableArray.prototype.draw;\n\n/**\n * (To be filled)\n */\nclass CleanableArray extends LoopableArray {\n    /**\n     *\n     * @param initialCapacity\n     */\n    constructor(initialCapacity) {\n        super(initialCapacity);\n        this.recentRemovedElements = new LoopableArray(initialCapacity);\n    }\n    /**\n     * Updates the variable 'isToBeRemoved'.\n     * If it has cleanable child elements, calls clean() recursively and\n     * removes the child elements which are to be removed.\n     */\n    clean() {\n        this.recentRemovedElements.clear();\n        let validElementCount = 0;\n        for (let i = 0; i < this.length; i += 1) {\n            this.array[i].clean();\n            if (this.array[i].isToBeRemoved) {\n                this.recentRemovedElements.push(this.array[i]);\n                continue;\n            }\n            this.array[validElementCount] = this.array[i];\n            validElementCount += 1;\n        }\n        this.length = validElementCount;\n    }\n}\n\n/**\n * (To be filled)\n */\nclass CleanableSpriteArray extends CleanableArray {\n}\nCleanableSpriteArray.prototype.draw = SpriteArray.prototype.draw;\nCleanableSpriteArray.prototype.step = SpriteArray.prototype.step;\n\n/**\n * Object pool which calls the provided function for every element when using & recyling.\n * Intended to use with the library deePool, but can also be used with another implementation.\n */\nclass ObjectPool {\n    /**\n     *\n     * @param naivePool - The pool object with use() and recycle(obj) methods.\n     * @param useProcess - The callback function which will be called in use().\n     * @param recycleProcess - The callback function which will be called in recycle().\n     */\n    constructor(naivePool, useProcess, recycleProcess) {\n        this.naivePool = naivePool;\n        this.useProcess = useProcess || ((object) => { });\n        this.recycleProcess = recycleProcess || ((object) => { });\n        this.recycle = (usedObject) => {\n            this.recycleProcess(usedObject);\n            this.naivePool.recycle(usedObject);\n        };\n    }\n    /**\n     * Returns an object which is currently not in use.\n     */\n    use() {\n        const newObject = this.naivePool.use();\n        this.useProcess(newObject);\n        return newObject;\n    }\n    /**\n     * Recycles all elements of the provided array.\n     * @param array\n     */\n    recycleAll(array) {\n        array.loop(this.recycle);\n    }\n}\n/**\n * Array of pooled objects. Recycles every removing object when clean() has been called.\n */\nclass PoolableArray extends CleanableArray {\n    constructor(pool, initialCapacity) {\n        super(initialCapacity);\n        this.pool = pool;\n    }\n    clean() {\n        super.clean();\n        this.recentRemovedElements.loop(this.pool.recycle);\n        this.recentRemovedElements.clear();\n    }\n}\n\n/**\n * (To be filled)\n */\nclass ScaleFactor {\n    /**\n     *\n     * @param p - p5ex instance.\n     * @param { number } [value = 1]\n     */\n    constructor(p, value = 1) {\n        this.p = p;\n        this.internalValue = value;\n        this.internalReciprocalValue = 1 / value;\n    }\n    /**\n     * The numeric value of the scale factor.\n     */\n    get value() {\n        return this.internalValue;\n    }\n    set value(v) {\n        if (v === 0) {\n            this.internalValue = 0.0001;\n            this.internalReciprocalValue = 10000;\n            return;\n        }\n        this.internalValue = v;\n        this.internalReciprocalValue = 1 / v;\n    }\n    /**\n     * The reciprocal value of the scale factor.\n     */\n    get reciprocalValue() {\n        return this.internalReciprocalValue;\n    }\n    /**\n     * Calls scale().\n     */\n    applyScale() {\n        this.p.currentRenderer.scale(this.internalValue);\n    }\n    /**\n     * Calls scale() with the reciprocal value.\n     */\n    cancel() {\n        this.p.currentRenderer.scale(this.internalReciprocalValue);\n    }\n}\n\n/**\n * (To be filled)\n */\nclass DrawerBuilder {\n    /**\n     *\n     * @param p\n     */\n    constructor(p) {\n        /**\n         * Parameter for drawing.\n         */\n        this.drawParam = {};\n        this.p = p;\n    }\n    /**\n     * @param element\n     * @chainable\n     */\n    setElement(element) {\n        this.element = element;\n        return this;\n    }\n    /**\n     * @param positionRef\n     * @chainable\n     */\n    setPositionRef(positionRef) {\n        this.drawParam.positionRef = positionRef;\n        return this;\n    }\n    /**\n     * @param offsetPositionRef\n     * @chainable\n     */\n    setOffsetPositionRef(offsetPositionRef) {\n        this.drawParam.offsetPositionRef = offsetPositionRef;\n        return this;\n    }\n    /**\n     * @param rotationAngleRef\n     * @chainable\n     */\n    setRotationAngleRef(rotationAngleRef) {\n        this.drawParam.rotationAngleRef = rotationAngleRef;\n        return this;\n    }\n    /**\n     * @param scaleFactorRef\n     * @chainable\n     */\n    setScaleFactorRef(scaleFactorRef) {\n        this.drawParam.scaleFactorRef = scaleFactorRef;\n        return this;\n    }\n    /**\n     * @param shapeColorRef\n     * @chainable\n     */\n    setShapeColorRef(shapeColorRef) {\n        this.drawParam.shapeColorRef = shapeColorRef;\n        return this;\n    }\n    /**\n     * @param alphaChannelRef\n     * @chainable\n     */\n    setAlphaChannelRef(alphaChannelRef) {\n        this.drawParam.alphaChannelRef = alphaChannelRef;\n        return this;\n    }\n    /**\n     * @param strokeWeightRef\n     * @chainable\n     */\n    setStrokeWeightRef(strokeWeightRef) {\n        this.drawParam.strokeWeightRef = strokeWeightRef;\n        return this;\n    }\n    /**\n     * @param textSizeRef\n     * @chainable\n     */\n    setTextSizeRef(textSizeRef) {\n        this.drawParam.textSizeRef = textSizeRef;\n        return this;\n    }\n    /**\n     * Builds a p5ex.Drawer instance.\n     */\n    build() {\n        return new Drawer(this.p, this.element, this.drawParam);\n    }\n}\n/**\n * (To be filled)\n */\nclass Drawer {\n    /**\n     *\n     * @param p\n     * @param element\n     * @param drawParam\n     */\n    constructor(p, element, drawParam) {\n        this.p = p;\n        this.set(element, drawParam);\n    }\n    /**\n     * (To be filled)\n     * @param element\n     * @param drawParam\n     */\n    set(element, drawParam) {\n        this.element = element;\n        this.position = drawParam.positionRef || this.p.createVector();\n        this.offsetPosition = drawParam.offsetPositionRef || this.p.createVector();\n        this.rotation = drawParam.rotationAngleRef || NumberContainer.NULL;\n        this.scaleFactor = drawParam.scaleFactorRef || new ScaleFactor(this.p);\n        this.shapeColor = drawParam.shapeColorRef || ShapeColor.UNDEFINED;\n        this.alphaChannel = drawParam.alphaChannelRef || NumberContainer.NULL;\n        this.strokeWeight = drawParam.strokeWeightRef || NumberContainer.NULL;\n        this.textSize = drawParam.textSizeRef || NumberContainer.NULL;\n        this.procedureList = this.createProcedureList(drawParam);\n        this.procedureListLength = this.procedureList.length;\n    }\n    /**\n     * Draws the content.\n     */\n    draw() {\n        for (let i = 0, len = this.procedureListLength; i < len; i += 1) {\n            this.procedureList[i](this);\n        }\n    }\n    drawElement(drawer) {\n        drawer.element.draw();\n    }\n    createProcedureList(drawParam) {\n        const procedureList = [];\n        if (drawParam.shapeColorRef) {\n            if (drawParam.alphaChannelRef)\n                procedureList.push(this.alphaColor);\n            else\n                procedureList.push(this.color);\n        }\n        if (drawParam.textSizeRef)\n            procedureList.push(this.applyTextSize);\n        if (drawParam.strokeWeightRef)\n            procedureList.push(this.applyStrokeWeight);\n        if (drawParam.positionRef) {\n            if (drawParam.offsetPositionRef)\n                procedureList.push(this.translateWithOffset);\n            else\n                procedureList.push(this.translate);\n        }\n        else if (drawParam.offsetPositionRef)\n            procedureList.push(this.translateOnlyOffset);\n        if (drawParam.scaleFactorRef)\n            procedureList.push(this.scale);\n        if (drawParam.rotationAngleRef)\n            procedureList.push(this.rotate);\n        procedureList.push(this.drawElement);\n        if (drawParam.rotationAngleRef)\n            procedureList.push(this.cancelRotate);\n        if (drawParam.scaleFactorRef)\n            procedureList.push(this.cancelScale);\n        if (drawParam.positionRef) {\n            if (drawParam.offsetPositionRef)\n                procedureList.push(this.cancelTranslateWithOffset);\n            else\n                procedureList.push(this.cancelTranslate);\n        }\n        else if (drawParam.offsetPositionRef)\n            procedureList.push(this.cancelTranslateOnlyOffset);\n        return procedureList;\n    }\n    translate(drawer) {\n        drawer.p.currentRenderer.translate(drawer.position.x, drawer.position.y);\n    }\n    cancelTranslate(drawer) {\n        drawer.p.currentRenderer.translate(-drawer.position.x, -drawer.position.y);\n    }\n    translateOnlyOffset(drawer) {\n        drawer.p.currentRenderer.translate(drawer.offsetPosition.x, drawer.offsetPosition.y);\n    }\n    cancelTranslateOnlyOffset(drawer) {\n        drawer.p.currentRenderer.translate(-drawer.offsetPosition.x, -drawer.offsetPosition.y);\n    }\n    translateWithOffset(drawer) {\n        drawer.p.currentRenderer.translate(drawer.position.x + drawer.offsetPosition.x, drawer.position.y + drawer.offsetPosition.y);\n    }\n    cancelTranslateWithOffset(drawer) {\n        drawer.p.currentRenderer.translate(-(drawer.position.x + drawer.offsetPosition.x), -(drawer.position.y + drawer.offsetPosition.y));\n    }\n    rotate(drawer) {\n        drawer.p.currentRenderer.rotate(drawer.rotation.value);\n    }\n    cancelRotate(drawer) {\n        drawer.p.currentRenderer.rotate(-drawer.rotation.value);\n    }\n    scale(drawer) {\n        if (drawer.scaleFactor.value === 1)\n            return;\n        drawer.scaleFactor.applyScale();\n    }\n    cancelScale(drawer) {\n        if (drawer.scaleFactor.value === 1)\n            return;\n        drawer.scaleFactor.cancel();\n    }\n    color(drawer) {\n        drawer.shapeColor.applyColor();\n    }\n    alphaColor(drawer) {\n        drawer.shapeColor.applyColor(drawer.alphaChannel.value);\n    }\n    applyStrokeWeight(drawer) {\n        drawer.p.currentRenderer.strokeWeight(drawer.strokeWeight.value);\n    }\n    applyTextSize(drawer) {\n        drawer.p.currentRenderer.textSize(drawer.textSize.value);\n    }\n}\n\n/**\n * (To be filled)\n */\nclass ShapeType {\n    /**\n     * @param drawShape\n     */\n    constructor(drawShape) {\n        this.drawShape = drawShape;\n    }\n}\nconst COS60 = 1 / 2;\nconst SIN60 = Math.sqrt(3) / 2;\n\n/**\n * Set of shape types.\n */\nconst ShapeTypes = {\n    CIRCLE: new ShapeType((renderer, size) => { renderer.ellipse(0, 0, size, size); }),\n    SQUARE: new ShapeType((renderer, size) => { renderer.rect(0, 0, size, size); }),\n    REGULAR_TRIANGLE: new ShapeType((renderer, size) => {\n        const radius = 0.5 * size;\n        renderer.triangle(radius, 0, -COS60 * radius, -SIN60 * radius, -COS60 * radius, +SIN60 * radius);\n    }),\n    REGULAR_TRIANGLE_UPWARD: new ShapeType((renderer, size) => {\n        const radius = 0.5 * size;\n        renderer.triangle(0, radius, -SIN60 * radius, -COS60 * radius, +SIN60 * radius, -COS60 * radius);\n    }),\n};\n\n/**\n * (To be filled)\n */\nclass ScalableShape {\n    /**\n     *\n     * @param p5exInstance\n     * @param shapeType - type chosen from p5ex.ShapeTypes\n     * @param {number} baseShapeSize\n     * @param {NumberContainer} [scaleFactorRef]\n     */\n    constructor(p5exInstance, shapeType, baseShapeSize, scaleFactorRef = new NumberContainer(1)) {\n        this.p = p5exInstance;\n        this.shapeType = shapeType;\n        this.baseShapeSize = baseShapeSize;\n        this.scaleFactorRef = scaleFactorRef;\n    }\n    /**\n     * Draws the shape.\n     */\n    draw() {\n        this.shapeType.drawShape(this.p, this.scaleFactorRef.value * this.baseShapeSize);\n    }\n}\n\n/**\n * (To be filled)\n */\nclass LineSegment {\n    constructor(p, x1, y1, x2, y2) {\n        this.p = p;\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n    }\n    draw() {\n        this.p.currentRenderer.line(this.x1, this.y1, this.x2, this.y2);\n    }\n}\n\n/**\n * (To be filled)\n */\nclass CircularArc {\n    constructor(p, centerPosition, diameter, startAngle, endAngle, isClockwise, startRatio, endRatio) {\n        this.p = p;\n        this.centerPosition = centerPosition;\n        this.diameter = diameter;\n        this.startAngle = startAngle;\n        this.endAngle = endAngle;\n        this.startRatio = startRatio;\n        this.endRatio = endRatio;\n        this.isClockwise = isClockwise;\n    }\n    get isClockwise() { return this._isClockwise; }\n    set isClockwise(flag) {\n        this._isClockwise = flag;\n        this.validate = flag ? validateClockwise : validateAntiClockwise;\n        this.drawTrimmedArc = flag ? drawClockwise : drawAntiClockwise;\n    }\n    draw() {\n        this.validate(this);\n        const angleDifference = this.endAngle.value - this.startAngle.value;\n        const start = this.startAngle.value +\n            this.startRatio.value * angleDifference;\n        const end = this.startAngle.value +\n            this.endRatio.value * angleDifference;\n        this.drawTrimmedArc(this.p, this.centerPosition, this.diameter.value, start, end);\n    }\n}\nfunction validateClockwise(arc) {\n    if (arc.startAngle.value > arc.endAngle.value)\n        arc.endAngle.value += arc.p.TWO_PI;\n}\nfunction validateAntiClockwise(arc) {\n    if (arc.startAngle.value < arc.endAngle.value)\n        arc.endAngle.value -= arc.p.TWO_PI;\n}\nfunction drawClockwise(p, centerPosition, diameter, trimmedStartAngle, trimmedEndAngle) {\n    p.currentRenderer.arc(centerPosition.x, centerPosition.y, diameter, diameter, trimmedStartAngle, trimmedEndAngle);\n}\nfunction drawAntiClockwise(p, centerPosition, diameter, trimmedStartAngle, trimmedEndAngle) {\n    p.currentRenderer.arc(centerPosition.x, centerPosition.y, diameter, diameter, trimmedEndAngle, trimmedStartAngle);\n}\n\n// temporal vectors for use in QuadraticBezierCurve.\nconst tmpMidPoint1 = dummyP5.createVector();\nconst tmpMidPoint2 = dummyP5.createVector();\n/**\n * Trimmable quadratic bezier curve.\n */\nclass QuadraticBezierCurve {\n    /**\n     *\n     * @param p\n     * @param startPoint\n     * @param controlPoint\n     * @param endPoint\n     * @param resolution\n     * @param startRatioRef\n     * @param endRatioRef\n     */\n    constructor(p, startPoint, controlPoint, endPoint, resolution, startRatioRef, endRatioRef) {\n\n        this.pointList = new Array(resolution + 1);\n        this.resolution = resolution;\n        this.startRatio = startRatioRef;\n        this.endRatio = endRatioRef;\n        this.p = p;\n        for (let i = 0; i <= resolution; i += 1) {\n            const ratio2 = i / resolution;\n            const ratio1 = 1 - ratio2;\n            tmpMidPoint1.set(ratio1 * startPoint.x + ratio2 * controlPoint.x, ratio1 * startPoint.y + ratio2 * controlPoint.y);\n            tmpMidPoint2.set(ratio1 * controlPoint.x + ratio2 * endPoint.x, ratio1 * controlPoint.y + ratio2 * endPoint.y);\n            this.pointList[i] = p.createVector(ratio1 * tmpMidPoint1.x + ratio2 * tmpMidPoint2.x, ratio1 * tmpMidPoint1.y + ratio2 * tmpMidPoint2.y);\n        }\n    }\n    /**\n     * Returns true if the provided control point candidate is valid.\n     * @param controlPoint - The control point candidate to be checked.\n     * @param startPoint - The start point of the bezier curve.\n     * @param endPoint - The start point of the bezier curve.\n     * @param minDistance - Minimum distance between the control point and the start/end point.\n     * @param minAngle - Minimum angle of the control point.\n     * @param maxAngle - Maximum angle of the control point.\n     * @static\n     */\n    static checkControlPoint(controlPoint, startPoint, endPoint, minDistance, minAngle, maxAngle) {\n        const minDistanceSquared = minDistance * minDistance;\n        if (distSq(controlPoint, startPoint) < minDistanceSquared)\n            return false;\n        if (distSq(controlPoint, endPoint) < minDistanceSquared)\n            return false;\n        const angle = Math.abs(angleDifference(getDirectionAngle(controlPoint, startPoint), getDirectionAngle(controlPoint, endPoint)));\n        if (angle < minAngle)\n            return false;\n        if (angle > maxAngle)\n            return false;\n        return true;\n    }\n    draw() {\n        const startIndex = Math.floor(this.startRatio.value * this.resolution);\n        const endIndex = Math.floor(this.endRatio.value * this.resolution);\n        const indexRemainder = this.endRatio.value * this.resolution - endIndex;\n        const renderer = this.p.currentRenderer;\n        const points = this.pointList;\n        renderer.beginShape();\n        for (let i = startIndex; i <= endIndex; i += 1) {\n            renderer.vertex(points[i].x, points[i].y);\n        }\n        if (indexRemainder > 0) {\n            renderer.vertex(points[endIndex].x + indexRemainder * (points[endIndex + 1].x - points[endIndex].x), points[endIndex].y + indexRemainder * (points[endIndex + 1].y - points[endIndex].y));\n        }\n        renderer.endShape();\n    }\n}\n\n/**\n * Draws a sine wave.\n * @param p\n * @param drawingLength\n * @param peakToPeakAmplitude\n * @param waveLength\n */\nfunction drawSineWave(p, drawingLength, peakToPeakAmplitude, waveLength) {\n    const renderer = p.currentRenderer;\n    const peakAmplitude = 0.5 * peakToPeakAmplitude;\n    let reachedEnd = false;\n    renderer.beginShape();\n    for (let x = 0; x <= drawingLength; x += 1) {\n        if (x > drawingLength)\n            reachedEnd = true;\n        renderer.vertex(reachedEnd ? drawingLength : x, -peakAmplitude * Math.sin(p.TWO_PI * x / waveLength));\n        if (reachedEnd)\n            break;\n    }\n    renderer.endShape();\n}\n/**\n * Set color to the specified pixel.\n * @param renderer - Instance of either p5 or p5.Graphics.\n * @param x - The x index of the pixel.\n * @param y - The y index of the pixel.\n * @param red - The red value (0 - 255).\n * @param green - The green value (0 - 255).\n * @param blue - The blue value (0 - 255).\n * @param pixelDensity - If not specified, renderer.pixelDensity() will be called.\n */\nfunction setPixel(renderer, x, y, red, green, blue, alpha, pixelDensity) {\n    const g = renderer;\n    const d = pixelDensity || g.pixelDensity();\n    for (let i = 0; i < d; i += 1) {\n        for (let j = 0; j < d; j += 1) {\n            const idx = 4 * ((y * d + j) * g.width * d + (x * d + i));\n            g.pixels[idx] = red;\n            g.pixels[idx + 1] = green;\n            g.pixels[idx + 2] = blue;\n            g.pixels[idx + 3] = alpha;\n        }\n    }\n}\n/**\n * Lerp color to the specified pixel. The alpha channel remains unchanged.\n * @param renderer - Instance of either p5 or p5.Graphics.\n * @param x - The x index of the pixel.\n * @param y - The y index of the pixel.\n * @param red - The red value (0 - 255).\n * @param green - The green value (0 - 255).\n * @param blue - The blue value (0 - 255).\n * @param pixelDensity - If not specified, renderer.pixelDensity() will be called.\n * @param lerpRatio - The lerp ratio (0 - 1). If 1, the color will be replaced.\n */\nfunction lerpPixel(renderer, x, y, red, green, blue, pixelDensity, lerpRatio = 1) {\n    const g = renderer;\n    const d = pixelDensity || g.pixelDensity();\n    for (let i = 0; i < d; i += 1) {\n        for (let j = 0; j < d; j += 1) {\n            const idx = 4 * ((y * d + j) * g.width * d + (x * d + i));\n            g.pixels[idx] = lerp(g.pixels[idx], red, lerpRatio);\n            g.pixels[idx + 1] = lerp(g.pixels[idx + 1], green, lerpRatio);\n            g.pixels[idx + 2] = lerp(g.pixels[idx + 2], blue, lerpRatio);\n            // g.pixels[idx + 3] = 255;\n        }\n    }\n}\n/**\n * Fill the canvas or graphics (according to p.currentRenderer) with gradation.\n * @param p\n * @param backgroundColor\n * @param fromColor\n * @param toColor\n * @param lerpRatioExponent\n */\nfunction gradationBackground(p, backgroundColor, fromColor, toColor, lerpRatioExponent = 1) {\n    const g = p.currentRenderer;\n    g.background(backgroundColor);\n    g.strokeWeight(2);\n    for (let y = 0; y < g.width; y += 1) {\n        const lerpRatio = Math.pow(y / (g.height - 1), lerpRatioExponent);\n        g.stroke(p.lerpColor(fromColor, toColor, lerpRatio));\n        g.line(0, y, g.width - 1, y);\n    }\n}\n\n/**\n * Font class.\n */\nclass FontUnit {\n    /**\n     *\n     * @param p - p5ex instance.\n     * @param {string} name - The font name.\n     * @param {string} [filePath] - The file path of the font.\n     *     Not required if the font is already loaded (e.g. as a web font).\n     */\n    constructor(p, name, filePath) {\n        this.p = p;\n        this.filePath = filePath || null;\n        this.textFontArgument = name;\n    }\n    /**\n     * Loads the font file if the file path has been specified.\n     */\n    loadFile() {\n        if (this.filePath)\n            this.textFontArgument = this.p.loadFont(this.filePath);\n    }\n    /**\n     * Applies the font to the current renderer.\n     */\n    applyFont() {\n        this.p.currentRenderer.textFont(this.textFontArgument);\n    }\n}\n/**\n * Manager class of FontUnit.\n */\nclass FontManager {\n    /**\n     *\n     * @param p - p5ex instance.\n     */\n    constructor(p) {\n        this.p = p;\n        this.fontMap = new Map();\n    }\n    /**\n     * Registers a new font.\n     * @param p\n     * @param name\n     * @param filePath\n     * @chainable\n     */\n    register(name, filePath) {\n        this.fontMap.set(name, new FontUnit(this.p, name, filePath));\n        return this;\n    }\n    /**\n     * Calls loadFile() for each registered font. Should be called in preload().\n     */\n    loadAll() {\n        for (const font of this.fontMap.values()) {\n            font.loadFile();\n        }\n    }\n    /**\n     * Applies the specified font to the current renderer.\n     * @param {string} name - The font name.\n     */\n    applyFont(name) {\n        const font = this.fontMap.get(name);\n        if (font)\n            font.applyFont();\n    }\n}\n\n/**\n * (To be filled)\n */\nclass AngleQuantity {\n    /**\n     * Null object of AngleQuantity.\n     * @static\n     */\n    static get NULL() { return NULL$1; }\n    /**\n     *\n     * @param angle\n     * @param angleVelocity\n     */\n    constructor(angle = 0, angleVelocity = 0) {\n        this.angleReference = new NumberContainer(angle);\n        this.angleVelocityReference = new NumberContainer(angleVelocity);\n    }\n    /**\n     * Current angle value.\n     */\n    get angle() { return this.angleReference.value; }\n    set angle(v) { this.angleReference.value = v; }\n    /**\n     * Current anglular velocity value.\n     */\n    get angleVelocity() { return this.angleVelocityReference.value; }\n    set angleVelocity(v) { this.angleVelocityReference.value = v; }\n    /**\n     * Updates the angle.\n     */\n    step() {\n        this.angle += this.angleVelocity;\n    }\n}\nclass NullAngleQuantity extends AngleQuantity {\n    get angle() { return 0; }\n    set angle(v) { }\n    get angleVelocity() { return 0; }\n    set angleVelocity(v) { }\n    step() { }\n}\nconst NULL$1 = new NullAngleQuantity();\n\n/**\n * (To be filled)\n */\nclass KinematicQuantity {\n    constructor() {\n        this.position = new p5.Vector();\n        this.velocity = new p5.Vector();\n    }\n    /**\n     * Updates the position.\n     */\n    step() {\n        this.position.add(this.velocity);\n    }\n    /**\n     * Returns the current speed.\n     */\n    getSpeed() {\n        return this.velocity.mag();\n    }\n    /**\n     * Returns the current direction angle.\n     */\n    getDirection() {\n        return this.velocity.heading();\n    }\n    /**\n     * Adds the given value to the current speed.\n     * @param speedChange\n     */\n    addSpeed(speedChange) {\n        this.velocity.setMag(Math.max(0, this.velocity.mag() + speedChange));\n    }\n}\n\nconst temporalVector = dummyP5.createVector();\n/**\n * (To be filled)\n */\nclass PhysicsBody {\n    constructor() {\n        this.kinematicQuantity = new KinematicQuantity();\n        this.position = this.kinematicQuantity.position;\n        this.velocity = this.kinematicQuantity.velocity;\n        this.mass = 1;\n        this.collisionRadius = 0;\n        this.hasFriction = false;\n        this.decelerationFactor = 1;\n    }\n    /**\n     * X position.\n     */\n    get x() {\n        return this.position.x;\n    }\n    /**\n     * Y position.\n     */\n    get y() {\n        return this.position.y;\n    }\n    /**\n     * Z position.\n     */\n    get z() {\n        return this.position.z;\n    }\n    /**\n     * X velocity.\n     */\n    get vx() {\n        return this.velocity.x;\n    }\n    /**\n     * Y velocity.\n     */\n    get vy() {\n        return this.velocity.y;\n    }\n    /**\n     * Z velocity.\n     */\n    get vz() {\n        return this.velocity.z;\n    }\n    /**\n     * Returns the current speed.\n     */\n    getSpeed() {\n        return this.kinematicQuantity.getSpeed();\n    }\n    /**\n     * Returns the current direction angle.\n     */\n    getDirection() {\n        return this.kinematicQuantity.getDirection();\n    }\n    /**\n     * Sets the friction of the body.\n     * @param constant\n     */\n    setFriction(constant) {\n        if (constant === 0) {\n            this.hasFriction = false;\n            return;\n        }\n        this.hasFriction = true;\n        this.decelerationFactor = 1 - constant;\n    }\n    /**\n     * Constrains the current speed. Should be called every time if needed.\n     * @param maxSpeed\n     */\n    constrainSpeed(maxSpeed) {\n        if (this.velocity.magSq() > maxSpeed * maxSpeed)\n            this.velocity.setMag(maxSpeed);\n    }\n    /**\n     * Updates the body.\n     */\n    step() {\n        this.kinematicQuantity.step();\n        if (this.hasFriction) {\n            this.kinematicQuantity.velocity.mult(this.decelerationFactor);\n        }\n    }\n    /**\n     * Accelerates the body.\n     * @param x\n     * @param y\n     * @param z\n     */\n    accelerate(x, y, z) {\n        this.kinematicQuantity.velocity.add(x, y, z);\n    }\n    /**\n     * Apply the provided force to the body.\n     * @param force\n     */\n    applyForce(force) {\n        this.accelerate(force.x / this.mass, force.y / this.mass, force.z / this.mass);\n    }\n    /**\n     * Add the provided value to the speed of the body.\n     * @param speedChange\n     */\n    addSpeed(speedChange) {\n        this.kinematicQuantity.addSpeed(speedChange);\n    }\n    /**\n     * Returns true if the body collides the provided body.\n     * @param other\n     */\n    collides(other) {\n        return (distSq(this.position, other.position) <\n            this.collisionRadius * this.collisionRadius + other.collisionRadius * other.collisionRadius);\n    }\n    /**\n     * (To be filled)\n     * @param normalUnitVector\n     * @param restitution\n     */\n    bounce(normalUnitVector, restitution = 1) {\n        this.velocity.add(p5.Vector.mult(normalUnitVector, (1 + restitution) * p5.Vector.dot(this.velocity, p5.Vector.mult(normalUnitVector, -1))));\n    }\n    /**\n     * Applies attraction force to both this and the target body.\n     * @param {PhysicsBody} other - the other body to interact with\n     * @param {number} magnitudeFactor - the factor of magnitude other than the distance\n     * @param {number} minMag - the minimum magnitude\n     * @param {number} maxMag - the maximum magnitude\n     * @param {number} cutoffMag - does not apply force if magnitude is smaller than this\n     */\n    attractEachOther(other, magnitudeFactor, minMag = 0, maxMag, cutoffMag) {\n        const force = this.calculateAttractionForce(other.position, magnitudeFactor, minMag, maxMag, cutoffMag);\n        if (!force)\n            return;\n        this.applyForce(force);\n        force.mult(-1);\n        other.applyForce(force);\n    }\n    /**\n     * Applies attraction force to this body.\n     * @param {p5.Vector} targetPosition - the target position\n     * @param {number} magnitudeFactor - the factor of magnitude other than the distance\n     * @param {number} minMag - the minimum magnitude\n     * @param {number} maxMag - the maximum magnitude\n     * @param {number} cutoffMag - does not apply force if magnitude is smaller than this\n     */\n    attractToPoint(targetPosition, magnitudeFactor, minMag = 0, maxMag, cutoffMag) {\n        const force = this.calculateAttractionForce(targetPosition, magnitudeFactor, minMag, maxMag, cutoffMag);\n        if (!force)\n            return;\n        this.applyForce(force);\n    }\n    calculateAttractionForce(targetPosition, magnitudeFactor, minMag = 0, maxMag, cutoffMag) {\n        const tmpVec = temporalVector;\n        p5.Vector.sub(targetPosition, this.position, tmpVec); // set relative position\n        const distanceSquared = tmpVec.magSq();\n        let magnitude = Math.abs(magnitudeFactor) / distanceSquared;\n        if (cutoffMag && magnitude < cutoffMag)\n            return null;\n        if (maxMag)\n            magnitude = Math.min(Math.max(magnitude, minMag), maxMag);\n        else\n            magnitude = Math.max(magnitude, minMag);\n        tmpVec.setMag(magnitude); // set force\n        if (magnitudeFactor < 0)\n            tmpVec.mult(-1);\n        return tmpVec;\n    }\n}\n\n/**\n * Returns the 2D force vector which is to be applied to the load.\n * @param loadDirectionAngle - the direction angle from the fulcrum to the load\n * @param loadDistance - the distance between the fulcrum and the load\n * @param effortDistance - the distance between the fulcrum and the effort\n * @param effortForceMagnitude - the effort force magnitude\n * @param rotateClockwise - true if the load is to be rotated clockwise, otherwise false\n * @param target - the vector to receive the result. Will be newly created if not specified\n */\nfunction calculateLeverageForce(loadDirectionAngle, loadDistance, effortDistance, effortForceMagnitude, rotateClockwise, target) {\n    const force = target || dummyP5.createVector();\n    const forceDirectionAngle = loadDirectionAngle + (rotateClockwise ? -dummyP5.HALF_PI : dummyP5.HALF_PI);\n    force.set(Math.cos(forceDirectionAngle), Math.sin(forceDirectionAngle));\n    force.setMag(effortForceMagnitude * effortDistance / loadDistance); // load force\n    return force;\n}\n\n/**\n * (To be filled)\n */\nclass FrameCounter {\n    constructor() {\n        this.count = 0;\n    }\n    /**\n     * Resets the counter.\n     * @param count\n     */\n    resetCount(count = 0) {\n        this.count = count;\n        return this;\n    }\n    /**\n     * Increments the frame count.\n     */\n    step() {\n        this.count += 1;\n    }\n    /**\n     * Returns the mod.\n     * @param divisor\n     */\n    mod(divisor) {\n        return this.count % divisor;\n    }\n}\n\n/**\n * (To be filled)\n */\nclass TimedFrameCounter extends FrameCounter {\n    /**\n     * True if this counter is activated.\n     */\n    get isOn() { return this._isOn; }\n\n    /**\n     *\n     * @param durationFrameCount\n     * @param completeBehavior\n     */\n    constructor(durationFrameCount, completeBehavior = EMPTY_FUNCTION) {\n        super();\n        this._isOn = true;\n        this.completeBehavior = completeBehavior;\n        this.durationFrameCount = durationFrameCount;\n    }\n    /**\n     * Activate this counter.\n     * @param duration\n     * @chainable\n     */\n    on(duration) {\n        this._isOn = true;\n        if (duration)\n            this.durationFrameCount = duration;\n        return this;\n    }\n    /**\n     * Deactivate this counter.\n     * @chainable\n     */\n    off() {\n        this._isOn = false;\n        return this;\n    }\n    /**\n     * @override\n     */\n    step() {\n        if (!this._isOn)\n            return;\n        this.count += 1;\n        if (this.count > this.durationFrameCount) {\n            this.completeCycle();\n        }\n    }\n}\n\n/**\n * (To be filled)\n */\nclass LoopedFrameCounter extends TimedFrameCounter {\n    /**\n     *\n     * @param duration\n     * @param cycleCompleteBehavior\n     */\n    constructor(duration, cycleCompleteBehavior) {\n        super(duration, cycleCompleteBehavior);\n    }\n    /**\n     * @override\n     * @chainable\n     */\n    on(duration) {\n        super.on(duration);\n        return this;\n    }\n    /**\n     * @override\n     * @chainable\n     */\n    off() {\n        super.off();\n        return this;\n    }\n    /**\n     * @override\n     */\n    getProgressRatio() {\n        return this.count / this.durationFrameCount;\n    }\n    /**\n     * @override\n     */\n    completeCycle() {\n        this.completeBehavior();\n        this.count = 0;\n    }\n}\n\n/**\n * (To be filled)\n */\nclass NonLoopedFrameCounter extends TimedFrameCounter {\n    /**\n     * True if the given frame count duration has ellapsed already.\n     */\n    get isCompleted() { return this._isCompleted; }\n\n    /**\n     *\n     * @param durationFrameCount\n     * @param completeBehavior\n     */\n    constructor(durationFrameCount, completeBehavior) {\n        super(durationFrameCount, completeBehavior);\n        this._isCompleted = false;\n    }\n    /**\n     * @override\n     * @chainable\n     */\n    on(duration) {\n        super.on(duration);\n        return this;\n    }\n    /**\n     * @override\n     * @chainable\n     */\n    off() {\n        super.off();\n        return this;\n    }\n    /**\n     * @override\n     */\n    resetCount() {\n        super.resetCount();\n        this._isCompleted = false;\n        return this;\n    }\n    /**\n     * @override\n     */\n    getProgressRatio() {\n        return this._isCompleted ? 1 : this.count / this.durationFrameCount;\n    }\n    /**\n     * @override\n     */\n    completeCycle() {\n        this._isCompleted = true;\n        this._isOn = false;\n        this.completeBehavior();\n    }\n}\n\n/**\n * Holds a boolean value for each key which indicates if the key is currently down.\n */\nconst keyDown = new Map();\n/**\n * Begins to listen key events. Default behaviors for arrow keys will be prevented.\n */\nfunction listenKey() {\n    window.addEventListener('keydown', (event) => {\n        keyDown.set(event.key, true);\n        keyDown.set(event.code, true);\n        switch (event.key) {\n            case 'ArrowDown':\n            case 'ArrowUp':\n            case 'ArrowLeft':\n            case 'ArrowRight':\n                return false;\n            default:\n                return;\n        }\n    });\n    window.addEventListener('keyup', (event) => {\n        keyDown.set(event.key, false);\n        keyDown.set(event.code, false);\n        switch (event.key) {\n            case 'ArrowDown':\n            case 'ArrowUp':\n            case 'ArrowLeft':\n            case 'ArrowRight':\n                return false;\n            default:\n                return;\n        }\n    });\n}\n\n/**\n * Returns true if the mouse cursor is on the canvas.\n * @param p - p5ex instance.\n */\nfunction mouseOnCanvas(p) {\n    if (p.mouseX < 0)\n        return false;\n    if (p.mouseX > p.width)\n        return false;\n    if (p.mouseY < 0)\n        return false;\n    if (p.mouseY > p.height)\n        return false;\n    return true;\n}\n\n/**\n * Extension of p5 class.\n */\nclass p5exClass extends p5 {\n    /**\n     * Sets the current renderer object.\n     * @param renderer\n     */\n    setCurrentRenderer(renderer) {\n        this.currentRenderer = renderer;\n    }\n    /**\n      * The non-scaled width of the canvas.\n      */\n    get nonScaledWidth() {\n        return this.scalableCanvas.nonScaledWidth;\n    }\n    /**\n     * The non-scaled height of the canvas.\n     */\n    get nonScaledHeight() {\n        return this.scalableCanvas.nonScaledHeight;\n    }\n\n    /**\n     * The ideal frame rate which was set by setFrameRate().\n     */\n    get idealFrameRate() { return this._idealFrameRate; }\n    /**\n     * Anglular displacement in radians per frame which corresponds to 1 cycle per second.\n     * Set by setFrameRate().\n     */\n    get unitAngleSpeed() { return this._unitAngleSpeed; }\n    /**\n     * Positional displacement per frame which corresponds to 1 unit length per second.\n     * Set by setFrameRate().\n     */\n    get unitSpeed() { return this._unitSpeed; }\n    /**\n     * Change of speed per frame which corresponds to 1 unit speed per second.\n     * Set by setFrameRate().\n     */\n    get unitAccelerationMagnitude() { return this._unitAccelerationMagnitude; }\n    /**\n     * Constructor of class p5ex.\n     * @param sketch\n     * @param node\n     * @param sync\n     */\n    constructor(sketch, node, sync) {\n        super(sketch, typeof node === 'string' ? document.getElementById(node) || undefined : node, sync);\n        if (!node || typeof node === 'boolean') {\n            this.node = document.body;\n        }\n        else {\n            this.node = typeof node === 'string' ? document.getElementById(node) || document.body : node;\n        }\n        this.currentRenderer = this;\n        this.maxCanvasRegion = {\n            width: 0,\n            height: 0,\n            getShortSideLength() { return Math.min(this.width, this.height); },\n        };\n        this.updateMaxCanvasRegion();\n        this.setFrameRate();\n    }\n    /**\n     * Calls frameRate() and sets variables related to the frame rate.\n     * @param {number} [fps=60] - The ideal frame rate per second.\n     */\n    setFrameRate(fps = 60) {\n        this.frameRate(fps);\n        if (fps) {\n            this._idealFrameRate = fps;\n            this._unitAngleSpeed = 2 * Math.PI / this._idealFrameRate;\n            this._unitSpeed = 1 / this._idealFrameRate;\n            this._unitAccelerationMagnitude = this._unitSpeed / this._idealFrameRate;\n        }\n        return this;\n    }\n    /**\n     * Updates the value of the variable maxCanvasRegion.\n     */\n    updateMaxCanvasRegion() {\n        this.maxCanvasRegion.width = this.windowWidth;\n        this.maxCanvasRegion.height = this.windowHeight;\n        if (this.node === document.body)\n            return;\n        const containerRect = this.node.getBoundingClientRect();\n        this.maxCanvasRegion.width = containerRect.width;\n        this.maxCanvasRegion.height = containerRect.height;\n    }\n    /**\n     * Create an instance of ScalableCanvas. This includes calling of createCanvas().\n     * @param {ScalableCanvasType} type - Type chosen from p5ex.ScalableCanvasTypes.\n     * @param {ScalableCanvasParameters} [parameters] - Parameters for type CUSTOM.\n     * @param {string} [rendererType] - Either P2D or WEBGL.\n     */\n    createScalableCanvas(type, parameters, rendererType) {\n        this.scalableCanvasType = type;\n        this.scalableCanvas = new ScalableCanvas(this, this.createScalableCanvasParameter(type, parameters), this.node, rendererType);\n    }\n    /**\n     * Resizes the ScalableCanvas. Does not work on OpenProcessing.\n     * @param {ScalableCanvasType} [type] - Type chosen from p5ex.ScalableCanvasTypes.\n     *     If undefined, the last used type will be used again.\n     * @param {ScalableCanvasParameters} [parameters] - Parameters for type CUSTOM.\n     */\n    resizeScalableCanvas(type, parameters) {\n        this.scalableCanvas.resize(this.createScalableCanvasParameter(type || this.scalableCanvasType, parameters));\n    }\n    createScalableCanvasParameter(type, parameters) {\n        this.updateMaxCanvasRegion();\n        const maxShortSide = this.maxCanvasRegion.getShortSideLength();\n        switch (type) {\n            case ScalableCanvasTypes.SQUARE640x640:\n                return {\n                    scaledWidth: maxShortSide,\n                    scaledHeight: maxShortSide,\n                    nonScaledShortSideLength: 640,\n                };\n            case ScalableCanvasTypes.RECT640x480:\n                return {\n                    scaledWidth: maxShortSide,\n                    scaledHeight: 0.75 * maxShortSide,\n                    nonScaledShortSideLength: 480,\n                };\n            case ScalableCanvasTypes.FULL:\n                return {\n                    scaledWidth: this.maxCanvasRegion.width,\n                    scaledHeight: this.maxCanvasRegion.height,\n                    nonScaledShortSideLength: 640,\n                };\n            default:\n                return parameters || ScalableCanvas.DUMMY_PARAMETERS;\n        }\n    }\n}\n\nexport { p5exClass, loopArray, loopArrayBackwards, roundRobin, nestedLoopJoin, LoopableArray, EMPTY_FUNCTION, distSq, multiplyMatrixAndArray, angleDifference, getDirectionAngle, lerp, randomBetween, randomInt, randomIntBetween, getRandom, popRandom, randomSign, NumberContainer, WeightedRandomSelector, easeLinear, easeOutQuad, easeOutCubic, easeOutQuart, easeOutBack, getEasingFunction, dummyP5, Region, RectangleRegion, ScalableCanvas, ScalableCanvasTypes, ScreenEffect, ScreenShake, ScreenFlash, AlphaBackground, mouseIsInCanvas, TwoDimensionalArray, NaiveEdge, NaiveCell, NullCell, Grid, DrawableArray, SteppableArray, SpriteArray, CleanableArray, CleanableSpriteArray, ObjectPool, PoolableArray, ShapeColor, RandomShapeColor, setIlluminant, cielabColor, cielchColor, Illuminants, degamma, subtractColor, hsbColor, Drawer, DrawerBuilder, ShapeType, ShapeTypes, ScalableShape, LineSegment, CircularArc, QuadraticBezierCurve, drawSineWave, setPixel, lerpPixel, gradationBackground, FontUnit, FontManager, ScaleFactor, AngleQuantity, KinematicQuantity, PhysicsBody, calculateLeverageForce, FrameCounter, LoopedFrameCounter, NonLoopedFrameCounter, keyDown, listenKey, mouseOnCanvas };\n","import * as p5ex from 'p5ex';\r\n\r\n(p5 as any).disableFriendlyErrors = true;\r\n\r\nconst SKETCH_NAME = 'BooleanNetwork';\r\nconst OPENPROCESSING = false;\r\n\r\nif (OPENPROCESSING) new (p5 as any)();\r\n\r\n/*\r\nfunction easeOutInQuad(ratio: number): number {\r\n  return ratio < 0.5 ? p5ex.easeOutQuad(2 * ratio) / 2 : 0.5 + Math.pow(2 * (ratio - 0.5), 2) / 2;\r\n}\r\n*/\r\n\r\nfunction easeInOutQuad(ratio: number): number {\r\n  return ratio < 0.5 ? Math.pow(2 * ratio, 2) / 2 : 0.5 + p5ex.easeOutQuad(2 * (ratio - 0.5)) / 2;\r\n}\r\n\r\n// boolean functions\r\n\r\nconst copyFunction = (input) => { return input[0]; };\r\nconst notFunction = (input) => { return !input[0]; }; // not\r\nconst andFunction = (input) => { return input[0] && input[1]; };  // and\r\nconst orFunction = (input) => { return input[0] || input[1]; };  // or\r\nconst nandFunction = (input) => { return !andFunction(input); }; // nand\r\nconst norFunction = (input) => { return !orFunction(input); }; // nor\r\nconst xorFunction = (input) => { return input[0] ^ input[1]; }; // xor\r\nconst xnorFunction = (input) => { return !xorFunction(input); };  // xnor\r\nconst andFunction3 = (input) => { return input[0] && input[1] && input[2]; };  // and\r\nconst orFunction3 = (input) => { return input[0] || input[1] || input[2]; };  // or\r\nconst nandFunction3 = (input) => { return !andFunction3(input); }; // nand\r\nconst norFunction3 = (input) => { return !orFunction3(input); }; // nor\r\n\r\n\r\nclass BooleanNode implements p5ex.Sprite {\r\n  public isNull = false;\r\n  public state: boolean = true; // Math.random() < 0.5 ? true : false;\r\n  public readonly predecessorNodes: BooleanNode[] = [];\r\n  public readonly position: p5.Vector;\r\n  protected readonly nodeColor: p5ex.ShapeColor;\r\n  protected readonly markColor: p5ex.ShapeColor;\r\n  protected previousState: boolean = this.state;\r\n  protected booleanFunction = (input: boolean[]) => { return true; };\r\n  protected markScaleFactor = 1;\r\n\r\n  constructor(protected readonly p: p5ex.p5exClass) {\r\n    this.position = p.createVector();\r\n    this.nodeColor = new p5ex.ShapeColor(\r\n      p, null, p.color(p5ex.cielchColor(70, 80, p.random(p.TWO_PI))),\r\n    );\r\n    this.markColor = new p5ex.ShapeColor(p, p.color(32), null);\r\n  }\r\n\r\n  step(): void {\r\n    const currentCycleFrameCount = this.p.frameCount % this.p.idealFrameRate;\r\n    const progressRatio = currentCycleFrameCount / this.p.idealFrameRate;\r\n    this.markScaleFactor = p5ex.easeOutQuad(\r\n      Math.min(Math.min(progressRatio, 1 - progressRatio) * 5, 1),\r\n    );\r\n\r\n    switch (currentCycleFrameCount) {\r\n      case 0:\r\n        const input: boolean[] = [];\r\n\r\n        for (const predecessor of this.predecessorNodes) {\r\n          input.push(predecessor.state);\r\n        }\r\n\r\n        this.state = this.booleanFunction(input);\r\n\r\n        break;\r\n      case 1:\r\n        this.previousState = this.state;\r\n        break;\r\n    }\r\n  }\r\n\r\n  draw(): void {\r\n    const p = this.p;\r\n    const position = this.position;\r\n\r\n    // this.nodeColor.applyColor();\r\n    // p.ellipse(position.x, position.y, 40, 40);\r\n\r\n    this.markColor.applyColor();\r\n\r\n    if (this.state) {\r\n      p.strokeWeight(4.5);\r\n      const halfLength = this.markScaleFactor * 12;\r\n      p.line(\r\n        position.x, position.y - halfLength,\r\n        position.x, position.y + halfLength,\r\n      );\r\n    } else {\r\n      p.strokeWeight(4);\r\n      const diameter = this.markScaleFactor * 20;\r\n      p.ellipse(\r\n        position.x, position.y, diameter, diameter,\r\n      );\r\n    }\r\n  }\r\n\r\n  setPosition(position: p5.Vector): void {\r\n    this.position.set(position);\r\n  }\r\n\r\n  receivesFrom(otherNode: BooleanNode): boolean {\r\n    for (const predecessor of this.predecessorNodes) {\r\n      if (predecessor === otherNode) return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  setBooleanFunction(): void {\r\n    switch (this.predecessorNodes.length) {\r\n      case 0:\r\n        throw 'Found no predecessor nodes.';\r\n      case 1:\r\n        this.booleanFunction = this.p.random([\r\n          copyFunction,\r\n          notFunction,\r\n        ]);\r\n        break;\r\n      case 2:\r\n        this.booleanFunction = this.p.random([\r\n          andFunction,\r\n          orFunction,\r\n          nandFunction,\r\n          norFunction,\r\n          xorFunction,\r\n          xorFunction,\r\n          xnorFunction,\r\n          xnorFunction,\r\n        ]);\r\n        break;\r\n      default:\r\n        this.booleanFunction = this.p.random([\r\n          andFunction3,\r\n          orFunction3,\r\n          nandFunction3,\r\n          norFunction3,\r\n        ]);\r\n        break;\r\n    }\r\n  }\r\n}\r\n\r\nclass BooleanEdge implements p5ex.Sprite {\r\n  protected readonly lineColor: p5.Color;\r\n  protected readonly onColor: p5ex.ShapeColor;\r\n  protected readonly offColor: p5ex.ShapeColor;\r\n  protected readonly startPoint: p5.Vector;\r\n  protected readonly endPoint: p5.Vector;\r\n\r\n  constructor(\r\n    protected readonly p: p5ex.p5exClass,\r\n    protected readonly nodeA: BooleanNode,\r\n    protected readonly nodeB: BooleanNode,\r\n  ) {\r\n    this.lineColor = p.color(32);\r\n    this.onColor = new p5ex.ShapeColor(p, null, p.color(96, 192, 96));\r\n    this.offColor = new p5ex.ShapeColor(p, null, p.color(128, 128, 192));\r\n    this.startPoint = p.createVector();\r\n    this.endPoint = p.createVector();\r\n  }\r\n\r\n  updatePosition(): void {\r\n    const A = this.nodeA.position;\r\n    const B = this.nodeB.position;\r\n    const angle = p5ex.getDirectionAngle(A, B);\r\n    const offset = 35;\r\n    this.startPoint.set(\r\n      A.x + offset * Math.cos(angle),\r\n      A.y + offset * Math.sin(angle),\r\n    );\r\n    this.endPoint.set(\r\n      B.x - offset * Math.cos(angle),\r\n      B.y - offset * Math.sin(angle),\r\n    );\r\n  }\r\n\r\n  step(): void {\r\n  }\r\n\r\n  draw(): void {\r\n    this.p.stroke(this.lineColor);\r\n    this.p.strokeWeight(1);\r\n    this.p.line(\r\n      this.startPoint.x, this.startPoint.y,\r\n      this.endPoint.x, this.endPoint.y,\r\n    );\r\n\r\n    const currentCycleFrameCount = this.p.frameCount % this.p.idealFrameRate;\r\n\r\n    if (currentCycleFrameCount === 0) return;\r\n\r\n    const progressRatio = currentCycleFrameCount / this.p.idealFrameRate;\r\n    const easingRatio = easeInOutQuad(progressRatio);\r\n    const alphaRatio = Math.sin(Math.PI * progressRatio);\r\n    const size = alphaRatio * 8;\r\n\r\n    const x = this.p.lerp(this.startPoint.x, this.endPoint.x, easingRatio);\r\n    const y = this.p.lerp(this.startPoint.y, this.endPoint.y, easingRatio);\r\n\r\n    if (this.nodeA.state) this.onColor.applyColor(); else this.offColor.applyColor();\r\n\r\n    this.p.ellipse(x, y, size, size);\r\n  }\r\n}\r\n\r\n\r\n\r\nconst sketch = (p: p5ex.p5exClass) => {\r\n  // ---- variables\r\n  let backgroundPixels: number[];\r\n  let timeoutId = -1;\r\n  const booleanNodes = new p5ex.SpriteArray<BooleanNode>(16);\r\n  const booleanEdges = new p5ex.SpriteArray<BooleanEdge>();\r\n\r\n  function getNearestNode(\r\n    booleanNodes: p5ex.TwoDimensionalArray<BooleanNode>, xIndex: number, yIndex: number,\r\n    xIndexChange: 1 | 0 | -1, yIndexChange: 1 | 0 | -1, shallow: boolean = false,\r\n  ): BooleanNode | null {\r\n    let result: BooleanNode | null = null;\r\n    let currentXIndex = xIndex;\r\n    let currentYIndex = yIndex;\r\n\r\n    while (result === null) {\r\n      currentXIndex += xIndexChange;\r\n\r\n      if (currentXIndex < 0 || currentXIndex >= booleanNodes.xCount) break;\r\n\r\n      currentYIndex += yIndexChange;\r\n\r\n      if (currentYIndex < 0 || currentYIndex >= booleanNodes.yCount) break;\r\n\r\n      const currentNode = booleanNodes.get2D(currentXIndex, currentYIndex);\r\n\r\n      if (currentNode.isNull) continue;\r\n\r\n      result = currentNode;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  function getNearestNodes(\r\n    booleanNodes: p5ex.TwoDimensionalArray<BooleanNode>, xIndex: number, yIndex: number,\r\n  ): BooleanNode[] {\r\n    const result: BooleanNode[] = [];\r\n\r\n    const indexSet: [1 | 0 | -1, 1 | 0 | -1][] = [\r\n      [1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1], [0, -1], [1, -1],\r\n    ];\r\n\r\n    for (const index of indexSet) {\r\n      const nearestNode = getNearestNode(booleanNodes, xIndex, yIndex, index[0], index[1]);\r\n      if (nearestNode) result.push(nearestNode);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  function createNetwork(xCount = 5, yCount = 5, nullCount = 7): boolean {\r\n    booleanNodes.clear();\r\n    booleanEdges.clear();\r\n\r\n    const nodeCandidates = new p5ex.TwoDimensionalArray<BooleanNode>(\r\n      xCount, yCount, new BooleanNode(p),\r\n    );\r\n\r\n    for (let i = 0; i < nodeCandidates.length; i += 1) {\r\n      nodeCandidates.array[i] = new BooleanNode(p);\r\n    }\r\n\r\n    const nullNodeCandidates = nodeCandidates.array.slice(0, nodeCandidates.length);\r\n\r\n    for (let i = 0; i < nullCount; i += 1) {\r\n      p5ex.popRandom(nullNodeCandidates).isNull = true;\r\n    }\r\n\r\n    for (let i = 0; i < xCount; i += 1) {\r\n      const x = (1 + i) * (p.nonScaledWidth / (xCount + 1));\r\n\r\n      for (let k = 0; k < yCount; k += 1) {\r\n        const currentNode = nodeCandidates.get2D(i, k);\r\n\r\n        if (currentNode.isNull) continue;\r\n\r\n        const y = (1 + k) * (p.nonScaledHeight / (yCount + 1));\r\n        currentNode.setPosition(p.createVector(x, y));\r\n\r\n        const predecessorCandidates = getNearestNodes(nodeCandidates, i, k);\r\n\r\n        const requiredPredecessorCount = Math.min(\r\n          p.random([1, 2, 3]),\r\n          predecessorCandidates.length,\r\n        );\r\n\r\n        while (currentNode.predecessorNodes.length < requiredPredecessorCount) {\r\n          if (predecessorCandidates.length <= 0) return false;  // for safety; not necessary\r\n\r\n          const predecessor = p5ex.popRandom(predecessorCandidates);\r\n          const newEdge = new BooleanEdge(p, predecessor, currentNode);\r\n\r\n          if (predecessor.receivesFrom(currentNode)) continue;\r\n\r\n          currentNode.predecessorNodes.push(predecessor);\r\n          booleanEdges.push(newEdge);\r\n        }\r\n\r\n        booleanNodes.push(currentNode);\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  function resetNetwork(): void {\r\n    let retryCount = 0;\r\n\r\n    while (!createNetwork()) {\r\n      retryCount += 1;\r\n      if (retryCount > 1000) throw 'Could not create a valid boolean network.';\r\n    }\r\n\r\n    booleanNodes.loop((n) => { n.setBooleanFunction(); });\r\n    booleanEdges.loop((e) => { e.updatePosition(); });\r\n  }\r\n\r\n  function reset(): void {\r\n    p.background(255);\r\n    p5ex.gradationBackground(p, p.color(255), p.color(255), p.color(248, 248, 252), 2);\r\n    p.loadPixels();\r\n    backgroundPixels = p.pixels;\r\n\r\n    resetNetwork();\r\n  }\r\n\r\n  // ---- Setup & Draw etc.\r\n  p.preload = () => {\r\n  };\r\n\r\n  p.setup = () => {\r\n    if (OPENPROCESSING) (window as any).noCanvas();\r\n\r\n    p.createScalableCanvas(\r\n      p5ex.ScalableCanvasTypes.SQUARE640x640,\r\n    );\r\n\r\n    p.setFrameRate(60);\r\n    p.rectMode(p.CENTER);\r\n\r\n    reset();\r\n  };\r\n\r\n  p.draw = () => {\r\n    p.pixels = backgroundPixels;\r\n    p.updatePixels();\r\n    p.scalableCanvas.scale();\r\n\r\n    booleanNodes.step();\r\n    booleanEdges.step();\r\n    booleanEdges.draw();\r\n    booleanNodes.draw();\r\n\r\n    p.scalableCanvas.cancelScale();\r\n  };\r\n\r\n  p.windowResized = () => {\r\n    p.resizeScalableCanvas();\r\n\r\n    if (timeoutId !== -1) clearTimeout(timeoutId);\r\n    timeoutId = setTimeout(\r\n      () => { reset(); },\r\n      200,\r\n    );\r\n  };\r\n\r\n  p.mouseClicked = () => {\r\n    resetNetwork();\r\n  };\r\n};\r\n\r\nnew p5ex.p5exClass(sketch, SKETCH_NAME);\r\n"],"names":["p5ex.easeOutQuad","p5ex.ShapeColor","p5ex.cielchColor","p5ex.getDirectionAngle","p5ex.SpriteArray","p5ex.TwoDimensionalArray","p5ex.popRandom","p5ex.gradationBackground","p5ex.ScalableCanvasTypes","p5ex.p5exClass"],"mappings":"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"}