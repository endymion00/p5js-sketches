{"version":3,"file":"sketch.js","sources":["../node_modules/p5ex/lib/p5ex.mjs","../src/main.ts"],"sourcesContent":["/**\n* An extension of p5.js.\n* Including module: no-more-for-loops (Copyright 2018 FAL, licensed under MIT).\n* GitHub repository: {@link https://github.com/fal-works/p5ex}\n* @module p5ex\n* @copyright 2018 FAL\n* @author FAL <falworks.contact@gmail.com>\n* @license MIT\n* @version 0.5.6\n*/\n\n/**\n * Spatial region.\n */\nclass Region {\n}\n/**\n * Rectangle-shaped spatial region.\n */\nclass RectangleRegion extends Region {\n    get width() { return this.rightPositionX - this.leftPositionX; }\n    get height() { return this.bottomPositionY - this.topPositionY; }\n    get area() { return this.width * this.height; }\n    constructor(x1, y1, x2, y2, margin = 0) {\n        super();\n        this.leftPositionX = x1 - margin;\n        this.topPositionY = y1 - margin;\n        this.rightPositionX = x2 + margin;\n        this.bottomPositionY = y2 + margin;\n    }\n    contains(position, margin = 0) {\n        return (position.x >= this.leftPositionX - margin && position.x <= this.rightPositionX + margin &&\n            position.y >= this.topPositionY - margin && position.y <= this.bottomPositionY + margin);\n    }\n    constrain(position, margin = 0) {\n        if (position.x < this.leftPositionX - margin)\n            position.x = this.leftPositionX - margin;\n        else if (position.x > this.rightPositionX + margin)\n            position.x = this.rightPositionX + margin;\n        if (position.y < this.topPositionY - margin)\n            position.y = this.topPositionY - margin;\n        else if (position.y > this.bottomPositionY + margin)\n            position.y = this.bottomPositionY + margin;\n    }\n}\n// default region -> add\n\n/**\n * (To be filled)\n * @hideConstructor\n */\nclass ScalableCanvas {\n    constructor(p5Instance, parameter, node, rendererType) {\n        this.p = p5Instance;\n        this.canvasElement = p5Instance.createCanvas(parameter.scaledWidth, parameter.scaledHeight, rendererType);\n        if (this.canvasElement && 'parent' in this.canvasElement) {\n            this.canvasElement.parent(node);\n        }\n        this.region = new RectangleRegion(0, 0, 0, 0);\n        this.nonScaledShortSideLength = parameter.nonScaledShortSideLength;\n        this.updateSize();\n    }\n\n    /**\n     * (To be filled)\n     */\n    get scaleFactor() {\n        return this._scaleFactor;\n    }\n    /**\n     * (To be filled)\n     */\n    get nonScaledWidth() {\n        return this._nonScaledWidth;\n    }\n    /**\n     * (To be filled)\n     */\n    get nonScaledHeight() {\n        return this._nonScaledHeight;\n    }\n    /**\n     * (To be filled)\n     */\n    get aspectRatio() {\n        return this._aspectRatio;\n    }\n    /**\n     * (To be filled)\n     * @param parameter\n     */\n    resize(parameter) {\n        this.p.resizeCanvas(parameter.scaledWidth, parameter.scaledHeight);\n        this.nonScaledShortSideLength = parameter.nonScaledShortSideLength;\n        this.updateSize();\n    }\n    /**\n     * (To be filled)\n     */\n    updateSize() {\n        const p = this.p;\n        this._scaleFactor = Math.min(p.width, p.height) / this.nonScaledShortSideLength;\n        this._inversedScaleFactor = 1 / this._scaleFactor;\n        this._nonScaledWidth = p.width / this._scaleFactor;\n        this._nonScaledHeight = p.height / this._scaleFactor;\n        this._aspectRatio = p.width / p.height;\n        this.region.rightPositionX = this._nonScaledWidth;\n        this.region.bottomPositionY = this._nonScaledHeight;\n    }\n    /**\n     * Runs scale() of the current p5 instance for fitting the sketch to the current canvas.\n     * Should be called every frame before drawing objects on the canvas.\n     */\n    scale() {\n        this.p.scale(this._scaleFactor);\n    }\n    /**\n     * Runs scale() with the inversed scale factor.\n     */\n    cancelScale() {\n        this.p.scale(this._inversedScaleFactor);\n    }\n    /**\n     * Converts a length value on the scaled canvas to the non-scaled one.\n     * Typically used for interpreting mouseX and mouseY.\n     * @param {number} scaledLength - scaled length value\n     */\n    getNonScaledValueOf(scaledLength) {\n        return scaledLength / this._scaleFactor;\n    }\n}\nScalableCanvas.DUMMY_PARAMETERS = {\n    scaledWidth: 100,\n    scaledHeight: 100,\n    nonScaledShortSideLength: 100,\n};\n\n/**\n * (To be filled)\n * (This is not implemented as an enum because it is not supported by rollup)\n */\nconst ScalableCanvasTypes = {\n    SQUARE640x640: 'SQUARE640x640',\n    RECT640x480: 'RECT640x480',\n    FULL: 'FULL',\n    CUSTOM: 'CUSTOM',\n};\n\nclass NormalColorUnit {\n    constructor(p, p5Color) {\n        this.p = p;\n        this.p5Color = p5Color;\n    }\n    stroke() {\n        this.p.currentRenderer.stroke(this.p5Color);\n    }\n    fill() {\n        this.p.currentRenderer.fill(this.p5Color);\n    }\n}\nclass NoColorUnit {\n    constructor(p) {\n        this.p = p;\n    }\n    stroke() {\n        this.p.currentRenderer.noStroke();\n    }\n    fill() {\n        this.p.currentRenderer.noFill();\n    }\n}\nclass UndefinedColorUnit {\n    stroke() {\n    }\n    fill() {\n    }\n}\nclass AlphaColorUnit {\n    constructor(p, c, alphaResolution = 256) {\n        this.p = p;\n        const array = [];\n        for (let alphaFactor = 0; alphaFactor < alphaResolution; alphaFactor += 1) {\n            array.push(p.color(p.red(c), p.green(c), p.blue(c), p.alpha(c) * alphaFactor / (alphaResolution - 1)));\n        }\n        this.colorArray = array;\n        this.maxIndex = alphaResolution - 1;\n    }\n    stroke(alphaValue) {\n        this.p.currentRenderer.stroke(this.getColor(alphaValue));\n    }\n    fill(alphaValue) {\n        this.p.currentRenderer.fill(this.getColor(alphaValue));\n    }\n    getColor(alphaValue) {\n        return this.colorArray[alphaValue ? Math.floor(this.p.map(alphaValue, 0, 255, 0, this.maxIndex)) : this.maxIndex];\n    }\n}\nfunction colorUnit(p, p5Color, alphaEnabled, alphaResolution) {\n    if (!p || p5Color === undefined)\n        return new UndefinedColorUnit();\n    if (p5Color === null)\n        return new NoColorUnit(p);\n    if (alphaEnabled)\n        return new AlphaColorUnit(p, p5Color, alphaResolution);\n    return new NormalColorUnit(p, p5Color);\n}\n/**\n * Composition of two p5.Color instances. One for stroke(), one for fill().\n */\nclass ShapeColor {\n    /**\n     *\n     * @param p - p5ex instance.\n     * @param {p5.Color | null | undefined} strokeColor - Color for stroke(). Null means noStroke().\n     * @param {p5.Color | null | undefined} fillColor - Color for fill(). Null means noFill().\n     * @param {boolean} [alphaEnabled]\n     * @param {number} [alphaResolution]\n     */\n    constructor(p, strokeColor, fillColor, alphaEnabled, alphaResolution) {\n        this.strokeColor = colorUnit(p, strokeColor, alphaEnabled, alphaResolution);\n        this.fillColor = colorUnit(p, fillColor, alphaEnabled, alphaResolution);\n    }\n    /**\n     * Applies colors to the current p5 renderer.\n     * @param {number} alphaValue - Alpha channel value (0 - 255)\n     */\n    applyColor(alphaValue) {\n        this.strokeColor.stroke(alphaValue);\n        this.fillColor.fill(alphaValue);\n    }\n}\n/**\n * Undefined object of p5ex.ShapeColor.\n * @static\n */\nShapeColor.UNDEFINED = new ShapeColor(undefined, undefined, undefined);\n\n/**\n * An empty function.\n */\nconst EMPTY_FUNCTION = () => { };\n/**\n * 1.5 * PI\n */\nconst ONE_AND_HALF_PI = 1.5 * Math.PI;\n\nconst dummyP5 = new p5((p) => {\n    p.setup = () => {\n        p.noCanvas();\n    };\n});\n\n/**\n * Calculates the squared value of the Euclidean distance between\n * two points (considering a point as a vector object).\n */\nfunction distSq(v1, v2) {\n    return Math.pow(v2.x - v1.x, 2) + Math.pow(v2.y - v1.y, 2) + Math.pow(v2.z - v1.z, 2);\n}\n/**\n * Multiplies the given matrix and array.\n * The number of matrix columns and the array length must be identical.\n * @param {number[][]} matrix - Any matrix.\n * @param {number[]} array - Any one-dimensional array of numbers.\n * @param {number[]} [target] - Target array for receiving the result.\n * @returns Product of the given values as an array.\n */\nfunction multiplyMatrixAndArray(matrix, array, target) {\n    const matrixRowCount = matrix.length;\n    const matrixColumnCount = matrix[0].length;\n\n    const resultArray = target || new Array(matrixRowCount);\n\n    for (let row = 0; row < matrixRowCount; row += 1) {\n        resultArray[row] = 0;\n        for (let col = 0; col < matrixColumnCount; col += 1) {\n            resultArray[row] += matrix[row][col] * array[col];\n        }\n    }\n    return resultArray;\n}\nconst TWO_PI = 2 * Math.PI;\n/**\n * Calculates the difference between two angles in range of -PI to PI.\n * @param angleA - the angle to subtract from\n * @param angleB - the angle to subtract\n */\nfunction angleDifference(angleA, angleB) {\n    let diff = (angleA - angleB) % TWO_PI;\n    if (diff < -Math.PI)\n        diff += TWO_PI;\n    else if (diff > Math.PI)\n        diff -= TWO_PI;\n    return diff;\n}\n/**\n * Calculates the direction angle from one vector to another.\n * @param referencePosition\n * @param targetPosition\n */\nfunction getDirectionAngle(referencePosition, targetPosition) {\n    return Math.atan2(targetPosition.y - referencePosition.y, targetPosition.x - referencePosition.x);\n}\n// Temporal vectors for calculation use in getClosestPositionOnLineSegment()\nconst tmpVectorAP = dummyP5.createVector();\nconst tmpVectorAB = dummyP5.createVector();\n/**\n * Just lerp.\n * @param startValue - The start value.\n * @param endValue - The end value.\n * @param ratio - The ratio between 0 and 1.\n */\nfunction lerp(startValue, endValue, ratio) {\n    return startValue + ratio * (endValue - startValue);\n}\n\n/**\n * Returns random value from the min number up to (but not including) the max number.\n */\nfunction randomBetween(min, max) {\n    return min + Math.random() * (max - min);\n}\n/**\n * Returns random integer from 0 up to (but not including) the max number.\n */\nfunction randomInt(maxInt) {\n    return Math.floor(Math.random() * maxInt);\n}\n/**\n * Returns random integer from the min number up to (but not including) the max number.\n */\nfunction randomIntBetween(minInt, maxInt) {\n    return minInt + randomInt(maxInt - minInt);\n}\n/**\n * Returns one of array elements randomly.\n * @param array\n */\nfunction getRandom(array) {\n    return array[randomInt(array.length)];\n}\n/**\n * Returns n or -n randomly. (n = provided number)\n * @param {number} n - any number\n */\nfunction randomSign(n) {\n    if (Math.random() < 0.5)\n        return n;\n    return -n;\n}\n/**\n * Returns and removes one array element randomly.\n * @param array\n */\nfunction popRandom(array) {\n    return array.splice(randomInt(array.length), 1)[0];\n}\n\n/**\n * Container class of number.\n */\nclass NumberContainer {\n    /**\n     * @constructor\n     * @param {number} value\n     */\n    constructor(value = 0) {\n        this.value = value;\n    }\n    valueOf() {\n        return this.value;\n    }\n}\n/**\n * Null object of NumberContainer.\n * @static\n */\nNumberContainer.NULL = new NumberContainer();\n\n/**\n * (To be filled)\n */\nclass WeightedRandomSelector {\n    constructor() {\n        this.candidateList = [];\n        this.candidateCount = 0;\n        this.totalProbabiligyWeight = 0;\n    }\n    /**\n     * Adds one element with provided weight of probability.\n     * @param element\n     * @param probabilityWeight\n     * @chainable\n     */\n    push(element, probabilityWeight) {\n        this.candidateList.push({\n            element,\n            threshold: this.totalProbabiligyWeight + probabilityWeight,\n        });\n        this.candidateCount += 1;\n        this.totalProbabiligyWeight += probabilityWeight;\n        return this;\n    }\n    /**\n     * Clears all elements.\n     * @chainable\n     */\n    clear() {\n        this.candidateList.length = 0;\n        this.candidateCount = 0;\n        this.totalProbabiligyWeight = 0;\n        return this;\n    }\n    /**\n     * Returns one element randomly.\n     * The probability for each element is:\n     * (probability weight of the element) / (total probability weight)\n     */\n    get() {\n        const rnd = Math.random() * this.totalProbabiligyWeight;\n        for (let i = 0; i < this.candidateCount; i += 1) {\n            if (rnd < this.candidateList[i].threshold)\n                return this.candidateList[i].element;\n        }\n        return this.candidateList[this.candidateCount - 1].element; // unreachable\n    }\n}\n\n/**\n * Linear easing function.\n * @param ratio\n */\nfunction easeLinear(ratio) {\n    return ratio;\n}\n/**\n * easeOutQuad.\n * @param ratio\n */\nfunction easeOutQuad(ratio) {\n    return -Math.pow(ratio - 1, 2) + 1;\n}\n/**\n * easeOutCubic.\n * @param ratio\n */\nfunction easeOutCubic(ratio) {\n    return Math.pow(ratio - 1, 3) + 1;\n}\n/**\n * easeOutQuart.\n * @param ratio\n */\nfunction easeOutQuart(ratio) {\n    return -Math.pow(ratio - 1, 4) + 1;\n}\nconst EASE_OUT_BACK_DEFAULT_COEFFICIENT = 1.70158;\n/**\n * easeOutBack.\n * @param ratio\n */\nfunction easeOutBack(ratio) {\n    const r = ratio - 1;\n    return ((EASE_OUT_BACK_DEFAULT_COEFFICIENT + 1) * Math.pow(r, 3)\n        + EASE_OUT_BACK_DEFAULT_COEFFICIENT * Math.pow(r, 2) + 1);\n}\n/**\n * Returns an easeOut function.\n * @param exponent - Integer from 1 to 4.\n */\nfunction getEasingFunction(exponent) {\n    switch (Math.floor(exponent)) {\n        default:\n        case 1:\n            return easeLinear;\n        case 2:\n            return easeOutQuad;\n        case 3:\n            return easeOutCubic;\n        case 4:\n            return easeOutQuart;\n    }\n}\n\n/**\n * (To be filled)\n */\nclass RandomShapeColor {\n    constructor() {\n        this.candidateArray = [];\n    }\n    /**\n     * (To be filled)\n     * @param createShapeColor - Any function which returns a p5ex.ShapeColor instance.\n     * @param {number} candidateCount - Number of color candidates to push.\n     */\n    pushCandidateFromFunction(createShapeColor, candidateCount) {\n        for (let i = 0; i < candidateCount; i += 1) {\n            this.candidateArray.push(createShapeColor());\n        }\n        return this;\n    }\n    /**\n     * (To be filled)\n     * @param {p5.Color} shapeColor - Any p5.Color instance.\n     * @param {number} candidateCount - Number of color candidates to push.\n     */\n    pushCandidate(shapeColor, candidateCount = 1) {\n        for (let i = 0; i < candidateCount; i += 1) {\n            this.candidateArray.push(shapeColor);\n        }\n        return this;\n    }\n    /**\n     * Clears all color candidates.\n     */\n    clear() {\n        this.candidateArray.length = 0;\n        return this;\n    }\n    /**\n     * Returns one of color candidates randomly.\n     */\n    get() {\n        return getRandom(this.candidateArray);\n    }\n}\n\nfunction createCielabToXyzFunc() {\n    const delta = 6 / 29;\n    const constantA = 16 / 116;\n    const constantB = 3 * delta * delta;\n    return (value) => {\n        if (value > delta)\n            return value * value * value;\n        return (value - constantA) * constantB;\n    };\n}\nconst cielabToXyzFunc = createCielabToXyzFunc();\n/**\n * Converts color values from CIELAB (D65) to XYZ.\n * @param {number[]} cielabValue - Value array of L*, a*, b* (D65).\n * @param {Illuminant} illuminant - Instance of Illuminant.\n * @param {number[]} [target] - Target array for receiving the result.\n * @returns {number[]} XYZ value array.\n */\nfunction cielabValueToXyzValue(cielabValue, illuminant, target) {\n    const yFactor = (cielabValue[0] + 16.0) / 116.0;\n    const xFactor = yFactor + cielabValue[1] / 500.0;\n    const zFactor = yFactor - cielabValue[2] / 200.0;\n    if (target) {\n        target[0] = illuminant.tristimulusValues[0] * cielabToXyzFunc(xFactor);\n        target[1] = illuminant.tristimulusValues[1] * cielabToXyzFunc(yFactor);\n        target[2] = illuminant.tristimulusValues[2] * cielabToXyzFunc(zFactor);\n        return target;\n    }\n    return [\n        illuminant.tristimulusValues[0] * cielabToXyzFunc(xFactor),\n        illuminant.tristimulusValues[1] * cielabToXyzFunc(yFactor),\n        illuminant.tristimulusValues[2] * cielabToXyzFunc(zFactor),\n    ];\n}\n\n/**\n * Matrix for conversion color values from XYZ to linear RGB.\n * Values from \"7. Conversion from XYZ (D65) to linear sRGB values\" in\n * http://www.color.org/chardata/rgb/sRGB.pdf (April 2015)\n * @constant {number[][]} xyzToLinearRgbConversionMatrix\n * @ignore\n */\nconst xyzToLinearRgbConversionMatrix = [\n    [3.2406255, -1.537208, -0.4986286],\n    [-0.9689307, 1.8757561, 0.0415175],\n    [0.0557101, -0.2040211, 1.0569959],\n];\n/**\n * CIE standard illuminant.\n */\nclass Illuminant {\n    constructor(name, tristimulusValues) {\n        this.name = name;\n        this.tristimulusValues = tristimulusValues;\n    }\n}\n\n/**\n * Map of illuminants.\n */\nconst Illuminants = {\n    D50: new Illuminant('D50', [0.9642, 1.0000, 0.8251]),\n    D55: new Illuminant('D55', [0.9568, 1.0000, 0.9214]),\n    D65: new Illuminant('D65', [0.95047, 1.00000, 1.08883]),\n    E: new Illuminant('E', [1, 1, 1]),\n};\n\n/**\n * Applies display gamma correction to the given number.\n * @param value - any number in a linear color space (0 - 1).\n * @ignore\n */\nfunction degamma(value) {\n    if (value <= 0.0031308)\n        return 12.92 * value;\n    return 1.055 * Math.pow(value, 1.0 / 2.4) - 0.055;\n}\n/**\n * Returns the difference of two colors. The alpha values of the original colors will be ignored.\n * @param {p5.Color} c1 - The color to subtract from\n * @param {p5.Color} c2 - The color to subtract\n * @param {number} [alphaValue] - Alpha value of the result color\n */\nfunction subtractColor(c1, c2, alphaValue) {\n    return dummyP5.color(dummyP5.red(c1) - dummyP5.red(c2), dummyP5.green(c1) - dummyP5.green(c2), dummyP5.blue(c1) - dummyP5.blue(c2), alphaValue);\n}\n/**\n * Creates a new p5.Color instance in HSB color mode and\n * immediately reset the color mode to default.\n * @param {number} h - Hue (0 - 360)\n * @param {number} s - Saturation (0 - 100)\n * @param {number} b - Brightness (0 - 100)\n * @param {number} [a] - Alpha (0 - 255)\n */\nfunction hsbColor(h, s, b, a) {\n    dummyP5.colorMode(dummyP5.HSB, 360, 100, 100, 255);\n    const c = dummyP5.color(h, s, b);\n    dummyP5.colorMode(dummyP5.RGB, 1, 1, 1, 255);\n    const gammaCorrectedColor = dummyP5.color(degamma(dummyP5.red(c)), degamma(dummyP5.green(c)), degamma(dummyP5.blue(c)), a);\n    dummyP5.colorMode(dummyP5.RGB, 255, 255, 255, 255);\n    return gammaCorrectedColor;\n}\n\nlet currentIlluminant = Illuminants.D50;\n/**\n * Sets the current illuminant. (e.g. D50, D65 etc.)\n * @param illuminant - Any Illuminant.\n * @example setIlluminant(Illuminants.D65);\n */\nfunction setIlluminant(illuminant) {\n    currentIlluminant = illuminant;\n}\nconst temporalArray1 = [0, 0, 0];\nconst temporalArray2 = [0, 0, 0];\nconst temporalArray3 = [0, 0, 0];\nconst temporalArray4 = [0, 0, 0];\nfunction assignArray(array, v0, v1, v2) {\n    array[0] = v0;\n    array[1] = v1;\n    array[2] = v2;\n    return array;\n}\n/**\n * Clips the given linear RGB factor to the valid range (0 - 1)\n * and converts it to an sRGB value (0 - 255).\n * @param factor - Factor of either red, green or blue in the linear RGB color space.\n * @returns sRGB value.\n * @ignore\n */\nfunction linearRgbFactorToSrgbValue(factor) {\n    return degamma(Math.min(Math.max(factor, 0), 1)) * 255;\n}\n/**\n * Converts CIELAB values to an array of RGB values (0 - 255).\n * @param {number} lValue - L*: Lightness (0 - 100)\n * @param {number} aValue - a* (0 - ca. 100)\n * @param {number} bValue - b* (0 - ca. 100)\n * @param {number} [alphaValue] - Alhpa value (0 - 255)\n * @returns New Array of sRGB values.\n */\nfunction cielabColor(lValue, aValue, bValue, alphaValue) {\n    const labValue = assignArray(temporalArray1, lValue, aValue, bValue);\n    const xyzValue = cielabValueToXyzValue(labValue, currentIlluminant, temporalArray2);\n    const rgbFactor = multiplyMatrixAndArray(xyzToLinearRgbConversionMatrix, xyzValue, temporalArray3);\n    const srgbValue = assignArray(temporalArray4, linearRgbFactorToSrgbValue(rgbFactor[0]), linearRgbFactorToSrgbValue(rgbFactor[1]), linearRgbFactorToSrgbValue(rgbFactor[2]));\n    return alphaValue ? [\n        srgbValue[0],\n        srgbValue[1],\n        srgbValue[2],\n        alphaValue,\n    ] : [\n        srgbValue[0],\n        srgbValue[1],\n        srgbValue[2],\n    ];\n}\n/**\n * Converts CIELCh values to an array of RGB values (0 - 255).\n * @param {number} lValue - L*: Lightness (0 - 100)\n * @param {number} cValue - C*: Chroma (0 - ca. 100)\n * @param {number} hValue - h*: Hue (0 - 2PI)\n * @param {number} [alphaValue] - Alhpa value (0 - 255)\n */\nfunction cielchColor(lValue, cValue, hValue, alphaValue) {\n    return cielabColor(lValue, cValue * Math.cos(hValue), cValue * Math.sin(hValue), alphaValue);\n}\n\n/**\n * (To be filled)\n */\nclass ScreenEffect {\n    constructor(p) {\n        this.p = p;\n    }\n}\n/**\n * (To be filled)\n */\nclass ScreenShake extends ScreenEffect {\n    constructor(p, dampingRatio = 0.95) {\n        super(p);\n        this.dampingRatio = dampingRatio;\n        this.amplitude = 0;\n        this.offsetX = 0;\n        this.offsetY = 0;\n    }\n    apply() {\n        if (this.amplitude === 0)\n            return;\n        this.offsetX = Math.random() * this.amplitude;\n        this.offsetY = Math.random() * this.amplitude;\n        this.p.currentRenderer.translate(this.offsetX, this.offsetY);\n        this.amplitude = this.amplitude * this.dampingRatio;\n        if (this.amplitude < 1)\n            this.amplitude = 0;\n    }\n    set(amplitude) {\n        this.amplitude = Math.max(this.amplitude, amplitude);\n    }\n    reset() {\n        this.amplitude = 0;\n    }\n    cancel() {\n        this.p.currentRenderer.translate(-this.offsetX, -this.offsetY);\n    }\n}\n/**\n * (To be filled)\n */\nclass ScreenFlash extends ScreenEffect {\n    constructor(p, flashColor = p.color(255)) {\n        super(p);\n        this.alphaValue = 0;\n        this.valueChange = 0;\n        this.flashColor = new ShapeColor(p, null, flashColor, true);\n    }\n    apply() {\n        if (this.alphaValue === 0)\n            return;\n        this.flashColor.applyColor(this.alphaValue);\n        this.p.currentRenderer.rect(0, 0, this.p.scalableCanvas.nonScaledWidth, this.p.scalableCanvas.nonScaledHeight);\n        this.alphaValue -= this.valueChange;\n        if (this.alphaValue < 1)\n            this.alphaValue = 0;\n    }\n    set(initialAlphaValue, durationSeconds) {\n        this.alphaValue = initialAlphaValue;\n        this.valueChange = initialAlphaValue / (durationSeconds * this.p.idealFrameRate);\n    }\n    reset() {\n        this.alphaValue = 0;\n    }\n}\n\n/**\n * (To be filled)\n */\nclass AlphaBackground {\n    /**\n     *\n     * @param p5exInstance\n     * @param backgroundColor\n     * @param drawIntervalFrameCount\n     * @param blendModeString\n     * @param defaultBlendModeString\n     */\n    constructor(p5exInstance, backgroundColor, drawIntervalFrameCount = 1, blendModeString, defaultBlendModeString) {\n        this.p = p5exInstance;\n        this.backgroundColor = backgroundColor;\n        this.drawIntervalFrameCount = drawIntervalFrameCount;\n        this.blendModeString = blendModeString;\n        this.defaultBlendModeString = defaultBlendModeString;\n    }\n    /**\n     * Draws the background.\n     */\n    draw() {\n        if (this.p.frameCount % this.drawIntervalFrameCount !== 0)\n            return;\n        if (this.blendModeString)\n            this.p.blendMode(this.blendModeString);\n        this.p.noStroke();\n        this.p.fill(this.backgroundColor);\n        this.p.rect(0, 0, this.p.width, this.p.height);\n        if (this.defaultBlendModeString)\n            this.p.blendMode(this.defaultBlendModeString);\n    }\n}\n\n/**\n * Returns true if the mouse is within the canvas.\n * @param p - The p5 instance.\n */\nfunction mouseIsInCanvas(p) {\n    if (p.mouseX < 0)\n        return false;\n    if (p.mouseX > p.width)\n        return false;\n    if (p.mouseY < 0)\n        return false;\n    if (p.mouseY > p.height)\n        return false;\n    return true;\n}\n\nfunction loopArrayLimited(array, callback, arrayLength) {\n    let i = 0;\n    while (i < arrayLength) {\n        callback(array[i], i, array);\n        i += 1;\n    }\n}\n/**\n * Executes a provided function once for each array element.\n * @param {Array} array\n * @param {loopArrayCallBack} callback\n */\nfunction loopArray(array, callback) {\n    loopArrayLimited(array, callback, array.length);\n}\nfunction loopArrayBackwardsLimited(array, callback, arrayLength) {\n\n    while (arrayLength--) {\n        callback(array[arrayLength], arrayLength, array);\n    }\n}\n/**\n * Executes a provided function once for each array element in descending order.\n * @param {Array} array\n * @param {loopArrayCallback} callback\n */\nfunction loopArrayBackwards(array, callback) {\n    loopArrayBackwardsLimited(array, callback, array.length);\n}\n/**\n * @callback loopArrayCallBack\n * @param {} currentValue\n * @param {number} [index]\n * @param {Array} [array]\n */\n\nfunction roundRobinLimited(array, callback, arrayLength) {\n    for (let i = 0, len = arrayLength - 1; i < len; i += 1) {\n        for (let k = i + 1; k < arrayLength; k += 1) {\n            callback(array[i], array[k]);\n        }\n    }\n}\n/**\n * Executes a provided function once for each pair within the array.\n * @param {Array} array\n * @param {roundRobinCallBack} callback\n */\nfunction roundRobin(array, callback) {\n    roundRobinLimited(array, callback, array.length);\n}\n/**\n * @callback roundRobinCallBack\n * @param {} element\n * @param {} otherElement\n */\n\nfunction nestedLoopJoinLimited(array, otherArray, callback, arrayLength, otherArrayLength) {\n    for (let i = 0; i < arrayLength; i += 1) {\n        for (let k = 0; k < otherArrayLength; k += 1) {\n            callback(array[i], otherArray[k]);\n        }\n    }\n}\n/**\n * Joins two arrays and executes a provided function once for each joined pair.\n * @param {Array} array\n * @param {Array} otherArray\n * @param {nestedLoopJoinCallBack} callback\n */\nfunction nestedLoopJoin(array, otherArray, callback) {\n    nestedLoopJoinLimited(array, otherArray, callback, array.length, otherArray.length);\n}\n/**\n * @callback nestedLoopJoinCallBack\n * @param {} element\n * @param {} otherElement\n */\n\n/**\n * A class containing an array and several loop methods.\n */\nclass LoopableArray {\n    /**\n     * @param {number} initialCapacity\n     */\n    constructor(initialCapacity = 256) {\n\n        this.array = new Array(initialCapacity);\n        this.length = 0;\n    }\n    /**\n     * Returns a specific element.\n     * It is recommended to check that you are going to specify a valid index number\n     * before calling this method.\n     * @returns The specified element.\n     */\n    get(index) {\n        return this.array[index];\n    }\n    /**\n     * Returns the last element.\n     * It is recommended to check that this array is not empty before calling this method.\n     * @returns The last element.\n     */\n    getLast() {\n        return this.array[this.length - 1];\n    }\n    /**\n     * Adds one element to the end of the array and returns the new length of the array.\n     * @param {} element - The element to add to the end of the array.\n     */\n    push(element) {\n        this.array[this.length] = element;\n        this.length += 1;\n        return this.length;\n    }\n    /**\n     * Adds elements to the end of the array and returns the new length of the array.\n     * @param {Array} array - The elements to add to the end of the array.\n     */\n    pushRawArray(array, arrayLength = array.length) {\n        for (let i = 0; i < arrayLength; i += 1) {\n            this.array[this.length + i] = array[i];\n        }\n        this.length += arrayLength;\n        return this.length;\n    }\n    /**\n     * Adds all elements from another LoopableArray and returns the new length of the array.\n     * @param {LoopableArray} otherLoopableArray\n     */\n    pushAll(otherLoopableArray) {\n        return this.pushRawArray(otherLoopableArray.array, otherLoopableArray.length);\n    }\n    /**\n     * Removes and returns the last element.\n     * It is recommended to check that this array is not empty before calling this method.\n     * @returns The last element.\n     */\n    pop() {\n        this.length -= 1;\n        return this.array[this.length];\n    }\n    /**\n     * Clears the array.\n     */\n    clear() {\n        this.length = 0;\n    }\n    /**\n     * @callback loopArrayCallBack\n     * @param {} currentValue\n     * @param {number} [index]\n     * @param {Array} [array]\n     */\n    /**\n     * Executes a provided function once for each array element.\n     * @param {loopArrayCallBack} callback\n     */\n    loop(callback) {\n        loopArrayLimited(this.array, callback, this.length);\n    }\n    /**\n     * Executes a provided function once for each array element in descending order.\n     * @param {loopArrayCallBack} callback\n     */\n    loopBackwards(callback) {\n        loopArrayBackwardsLimited(this.array, callback, this.length);\n    }\n    /**\n     * @callback elementPairCallBack\n     * @param {} element\n     * @param {} otherElement\n     */\n    /**\n     * Executes a provided function once for each pair within the array.\n     * @param {elementPairCallback} callback\n     */\n    roundRobin(callback) {\n        roundRobinLimited(this.array, callback, this.length);\n    }\n    /**\n     * Joins two arrays and executes a provided function once for each joined pair.\n     * @param {LoopableArray} otherArray\n     * @param {elementPairCallback} callback\n     */\n    nestedLoopJoin(otherArray, callback) {\n        nestedLoopJoinLimited(this.array, otherArray.array, callback, this.length, otherArray.length);\n    }\n}\n\n/**\n * (To be filled)\n */\nclass TwoDimensionalArray extends LoopableArray {\n    /**\n     * (To be filled)\n     * @param {number} xCount\n     * @param {number} yCount\n     * @param fillElement\n     */\n    constructor(xCount, yCount, fillElement) {\n        super(xCount * yCount);\n        this.xCount = xCount;\n        this.yCount = yCount;\n        if (fillElement) {\n            for (let i = 0, len = xCount * yCount; i < len; i += 1) {\n                this.push(fillElement);\n            }\n        }\n    }\n    /**\n     * Returns the specified element.\n     * @param x\n     * @param y\n     */\n    get2D(x, y) {\n        return this.array[x + this.xCount * y];\n    }\n    /**\n     * (To be filled)\n     * @param x\n     * @param y\n     * @param element\n     */\n    set2D(x, y, element) {\n        this.array[x + this.xCount * y] = element;\n    }\n}\n\n/**\n * A Naive implementation of an edge between two objects.\n */\nclass NaiveEdge {\n    /**\n     *\n     * @param nodeA\n     * @param nodeB\n     */\n    constructor(nodeA, nodeB) {\n        this.nodeA = nodeA;\n        this.nodeB = nodeB;\n    }\n    /**\n     * Returns true if the provided node is incident to this edge.\n     * @param node\n     */\n    isIncidentTo(node) {\n        return node === this.nodeA || node === this.nodeB;\n    }\n    /**\n     * Returns the adjacent node of the given node via this edge.\n     * If this edge is not incident to the given node, returns always the end point node.\n     * @param {T} node - any node which is incident to this edge\n     */\n    getAdjacentNode(node) {\n        if (node === this.nodeB)\n            return this.nodeA;\n        return this.nodeB;\n    }\n}\n\n/**\n * (To be filled)\n */\nclass NullCell {\n    getNeighborCell(relativeX, relativeY) {\n        return this;\n    }\n    setNeighborCell(relativeX, relativeY, cell) { }\n}\nconst NULL = new NullCell();\n/**\n * (To be filled)\n */\nclass NaiveCell {\n    /**\n     *\n     * @param neighborRange\n     */\n    constructor(neighborRange = 1) {\n        this.neighborCells = new TwoDimensionalArray(2 * neighborRange + 1, 2 * neighborRange + 1, NULL);\n    }\n    /**\n     * Returns the specified neighbor cell.\n     * @param {number} relativeX\n     * @param {number} relativeY\n     */\n    getNeighborCell(relativeX, relativeY) {\n        const neighborRange = Math.floor(this.neighborCells.xCount / 2);\n        if (relativeX < -neighborRange || relativeX > neighborRange ||\n            relativeY < -neighborRange || relativeY > neighborRange)\n            return NULL;\n        return this.neighborCells.get2D(relativeX + neighborRange, relativeY + neighborRange);\n    }\n    /**\n     * Sets the provided cell as a neighbor of this cell.\n     * @param relativeX\n     * @param relativeY\n     * @param cell\n     */\n    setNeighborCell(relativeX, relativeY, cell) {\n        const neighborRange = Math.floor(this.neighborCells.xCount / 2);\n        this.neighborCells.set2D(relativeX + neighborRange, relativeY + neighborRange, cell);\n    }\n}\n/**\n * (To be filled)\n */\nclass Grid {\n    /**\n     *\n     * @param {number} xCount\n     * @param {number} yCount\n     * @param {number} neighborRange\n     * @param {boolean} loopAtEndOfScreen\n     */\n    constructor(xCount, yCount, neighborRange, loopAtEndOfScreen, cellFactory, nullCell) {\n        this.nullCell = nullCell;\n        this.cell2DArray = new TwoDimensionalArray(xCount, yCount, nullCell);\n        this.cellIndexMap = new Map();\n        for (let yIndex = 0; yIndex < yCount; yIndex += 1) {\n            for (let xIndex = 0; xIndex < xCount; xIndex += 1) {\n                const cell = cellFactory(neighborRange);\n                this.cell2DArray.set2D(xIndex, yIndex, cell);\n                this.cellIndexMap.set(cell, { x: xIndex, y: yIndex });\n            }\n        }\n        this.cell2DArray.loop((cell) => {\n            this.setNeighborCells(cell, neighborRange, loopAtEndOfScreen);\n        });\n    }\n    /**\n     * Returns the specified cell.\n     * @param {number} x - X index.\n     * @param {number} y - Y index.\n     */\n    getCell(x, y) {\n        return this.cell2DArray.get2D(x, y);\n    }\n    /**\n     * Returns the x and y index of the given cell.\n     * @param cell\n     */\n    getCellIndex(cell) {\n        return this.cellIndexMap.get(cell) || { x: -1, y: -1 };\n    }\n    /**\n     * (To be filled)\n     * @param referenceCell\n     * @param {number} relX\n     * @param {number} relY\n     * @param {boolean} loopAtEndOfScreen\n     */\n    getRelativePositionCell(referenceCell, relX, relY, loopAtEndOfScreen) {\n        if (referenceCell === this.nullCell)\n            return referenceCell;\n        if (relX === 0 && relY === 0)\n            return referenceCell;\n        const referenceIndex = this.getCellIndex(referenceCell);\n        const targetIndex = {\n            x: referenceIndex.x + relX,\n            y: referenceIndex.y + relY,\n        };\n        if (loopAtEndOfScreen) {\n            if (targetIndex.x < 0)\n                targetIndex.x += this.cell2DArray.xCount;\n            else if (targetIndex.x >= this.cell2DArray.xCount)\n                targetIndex.x -= this.cell2DArray.xCount;\n            if (targetIndex.y < 0)\n                targetIndex.y += this.cell2DArray.yCount;\n            else if (targetIndex.y >= this.cell2DArray.yCount)\n                targetIndex.y -= this.cell2DArray.yCount;\n        }\n        else {\n            if (targetIndex.x < 0 || targetIndex.x >= this.cell2DArray.xCount ||\n                targetIndex.y < 0 || targetIndex.y >= this.cell2DArray.yCount)\n                return this.nullCell;\n        }\n        return this.cell2DArray.get2D(targetIndex.x, targetIndex.y);\n    }\n    setNeighborCells(referenceCell, neighborRange, loopAtEndOfScreen) {\n        for (let relativeX = -neighborRange; relativeX <= neighborRange; relativeX += 1) {\n            for (let relativeY = -neighborRange; relativeY <= neighborRange; relativeY += 1) {\n                referenceCell.setNeighborCell(relativeX, relativeY, this.getRelativePositionCell(referenceCell, relativeX, relativeY, loopAtEndOfScreen));\n            }\n        }\n    }\n}\n\n/**\n * (To be filled)\n */\nclass DrawableArray extends LoopableArray {\n    static drawFunction(value) {\n        value.draw();\n    }\n    /**\n     * Draws all child elements.\n     */\n    draw() {\n        this.loop(DrawableArray.drawFunction);\n    }\n}\n\n/**\n * (To be filled)\n */\nclass SteppableArray extends LoopableArray {\n    static stepFunction(value) {\n        value.step();\n    }\n    /**\n     * Steps all child elements.\n     */\n    step() {\n        this.loop(SteppableArray.stepFunction);\n    }\n}\n\n/**\n * (To be filled)\n */\nclass SpriteArray extends LoopableArray {\n}\nSpriteArray.prototype.step = SteppableArray.prototype.step;\nSpriteArray.prototype.draw = DrawableArray.prototype.draw;\n\n/**\n * (To be filled)\n */\nclass CleanableArray extends LoopableArray {\n    /**\n     *\n     * @param initialCapacity\n     */\n    constructor(initialCapacity) {\n        super(initialCapacity);\n        this.recentRemovedElements = new LoopableArray(initialCapacity);\n    }\n    /**\n     * Updates the variable 'isToBeRemoved'.\n     * If it has cleanable child elements, calls clean() recursively and\n     * removes the child elements which are to be removed.\n     */\n    clean() {\n        this.recentRemovedElements.clear();\n        let validElementCount = 0;\n        for (let i = 0; i < this.length; i += 1) {\n            this.array[i].clean();\n            if (this.array[i].isToBeRemoved) {\n                this.recentRemovedElements.push(this.array[i]);\n                continue;\n            }\n            this.array[validElementCount] = this.array[i];\n            validElementCount += 1;\n        }\n        this.length = validElementCount;\n    }\n}\n\n/**\n * (To be filled)\n */\nclass CleanableSpriteArray extends CleanableArray {\n}\nCleanableSpriteArray.prototype.draw = SpriteArray.prototype.draw;\nCleanableSpriteArray.prototype.step = SpriteArray.prototype.step;\n\n/**\n * Object pool which calls the provided function for every element when using & recyling.\n * Intended to use with the library deePool, but can also be used with another implementation.\n */\nclass ObjectPool {\n    /**\n     *\n     * @param naivePool - The pool object with use() and recycle(obj) methods.\n     * @param useProcess - The callback function which will be called in use().\n     * @param recycleProcess - The callback function which will be called in recycle().\n     */\n    constructor(naivePool, useProcess, recycleProcess) {\n        this.naivePool = naivePool;\n        this.useProcess = useProcess || ((object) => { });\n        this.recycleProcess = recycleProcess || ((object) => { });\n        this.recycle = (usedObject) => {\n            this.recycleProcess(usedObject);\n            this.naivePool.recycle(usedObject);\n        };\n    }\n    /**\n     * Returns an object which is currently not in use.\n     */\n    use() {\n        const newObject = this.naivePool.use();\n        this.useProcess(newObject);\n        return newObject;\n    }\n    /**\n     * Recycles all elements of the provided array.\n     * @param array\n     */\n    recycleAll(array) {\n        array.loop(this.recycle);\n    }\n}\n/**\n * Array of pooled objects. Recycles every removing object when clean() has been called.\n */\nclass PoolableArray extends CleanableArray {\n    constructor(pool, initialCapacity) {\n        super(initialCapacity);\n        this.pool = pool;\n    }\n    clean() {\n        super.clean();\n        this.recentRemovedElements.loop(this.pool.recycle);\n        this.recentRemovedElements.clear();\n    }\n}\n\n/**\n * (To be filled)\n */\nclass ScaleFactor {\n    /**\n     *\n     * @param p - p5ex instance.\n     * @param { number } [value = 1]\n     */\n    constructor(p, value = 1) {\n        this.p = p;\n        this.internalValue = value;\n        this.internalReciprocalValue = 1 / value;\n    }\n    /**\n     * The numeric value of the scale factor.\n     */\n    get value() {\n        return this.internalValue;\n    }\n    set value(v) {\n        if (v === 0) {\n            this.internalValue = 0.0001;\n            this.internalReciprocalValue = 10000;\n            return;\n        }\n        this.internalValue = v;\n        this.internalReciprocalValue = 1 / v;\n    }\n    /**\n     * The reciprocal value of the scale factor.\n     */\n    get reciprocalValue() {\n        return this.internalReciprocalValue;\n    }\n    /**\n     * Calls scale().\n     */\n    applyScale() {\n        this.p.currentRenderer.scale(this.internalValue);\n    }\n    /**\n     * Calls scale() with the reciprocal value.\n     */\n    cancel() {\n        this.p.currentRenderer.scale(this.internalReciprocalValue);\n    }\n}\n\n/**\n * (To be filled)\n */\nclass DrawerBuilder {\n    /**\n     *\n     * @param p\n     */\n    constructor(p) {\n        /**\n         * Parameter for drawing.\n         */\n        this.drawParam = {};\n        this.p = p;\n    }\n    /**\n     * @param element\n     * @chainable\n     */\n    setElement(element) {\n        this.element = element;\n        return this;\n    }\n    /**\n     * @param positionRef\n     * @chainable\n     */\n    setPositionRef(positionRef) {\n        this.drawParam.positionRef = positionRef;\n        return this;\n    }\n    /**\n     * @param offsetPositionRef\n     * @chainable\n     */\n    setOffsetPositionRef(offsetPositionRef) {\n        this.drawParam.offsetPositionRef = offsetPositionRef;\n        return this;\n    }\n    /**\n     * @param rotationAngleRef\n     * @chainable\n     */\n    setRotationAngleRef(rotationAngleRef) {\n        this.drawParam.rotationAngleRef = rotationAngleRef;\n        return this;\n    }\n    /**\n     * @param scaleFactorRef\n     * @chainable\n     */\n    setScaleFactorRef(scaleFactorRef) {\n        this.drawParam.scaleFactorRef = scaleFactorRef;\n        return this;\n    }\n    /**\n     * @param shapeColorRef\n     * @chainable\n     */\n    setShapeColorRef(shapeColorRef) {\n        this.drawParam.shapeColorRef = shapeColorRef;\n        return this;\n    }\n    /**\n     * @param alphaChannelRef\n     * @chainable\n     */\n    setAlphaChannelRef(alphaChannelRef) {\n        this.drawParam.alphaChannelRef = alphaChannelRef;\n        return this;\n    }\n    /**\n     * @param strokeWeightRef\n     * @chainable\n     */\n    setStrokeWeightRef(strokeWeightRef) {\n        this.drawParam.strokeWeightRef = strokeWeightRef;\n        return this;\n    }\n    /**\n     * @param textSizeRef\n     * @chainable\n     */\n    setTextSizeRef(textSizeRef) {\n        this.drawParam.textSizeRef = textSizeRef;\n        return this;\n    }\n    /**\n     * Builds a p5ex.Drawer instance.\n     */\n    build() {\n        return new Drawer(this.p, this.element, this.drawParam);\n    }\n}\n/**\n * (To be filled)\n */\nclass Drawer {\n    /**\n     *\n     * @param p\n     * @param element\n     * @param drawParam\n     */\n    constructor(p, element, drawParam) {\n        this.p = p;\n        this.set(element, drawParam);\n    }\n    /**\n     * (To be filled)\n     * @param element\n     * @param drawParam\n     */\n    set(element, drawParam) {\n        this.element = element;\n        this.position = drawParam.positionRef || this.p.createVector();\n        this.offsetPosition = drawParam.offsetPositionRef || this.p.createVector();\n        this.rotation = drawParam.rotationAngleRef || NumberContainer.NULL;\n        this.scaleFactor = drawParam.scaleFactorRef || new ScaleFactor(this.p);\n        this.shapeColor = drawParam.shapeColorRef || ShapeColor.UNDEFINED;\n        this.alphaChannel = drawParam.alphaChannelRef || NumberContainer.NULL;\n        this.strokeWeight = drawParam.strokeWeightRef || NumberContainer.NULL;\n        this.textSize = drawParam.textSizeRef || NumberContainer.NULL;\n        this.procedureList = this.createProcedureList(drawParam);\n        this.procedureListLength = this.procedureList.length;\n    }\n    /**\n     * Draws the content.\n     */\n    draw() {\n        for (let i = 0, len = this.procedureListLength; i < len; i += 1) {\n            this.procedureList[i](this);\n        }\n    }\n    drawElement(drawer) {\n        drawer.element.draw();\n    }\n    createProcedureList(drawParam) {\n        const procedureList = [];\n        if (drawParam.shapeColorRef) {\n            if (drawParam.alphaChannelRef)\n                procedureList.push(this.alphaColor);\n            else\n                procedureList.push(this.color);\n        }\n        if (drawParam.textSizeRef)\n            procedureList.push(this.applyTextSize);\n        if (drawParam.strokeWeightRef)\n            procedureList.push(this.applyStrokeWeight);\n        if (drawParam.positionRef) {\n            if (drawParam.offsetPositionRef)\n                procedureList.push(this.translateWithOffset);\n            else\n                procedureList.push(this.translate);\n        }\n        else if (drawParam.offsetPositionRef)\n            procedureList.push(this.translateOnlyOffset);\n        if (drawParam.scaleFactorRef)\n            procedureList.push(this.scale);\n        if (drawParam.rotationAngleRef)\n            procedureList.push(this.rotate);\n        procedureList.push(this.drawElement);\n        if (drawParam.rotationAngleRef)\n            procedureList.push(this.cancelRotate);\n        if (drawParam.scaleFactorRef)\n            procedureList.push(this.cancelScale);\n        if (drawParam.positionRef) {\n            if (drawParam.offsetPositionRef)\n                procedureList.push(this.cancelTranslateWithOffset);\n            else\n                procedureList.push(this.cancelTranslate);\n        }\n        else if (drawParam.offsetPositionRef)\n            procedureList.push(this.cancelTranslateOnlyOffset);\n        return procedureList;\n    }\n    translate(drawer) {\n        drawer.p.currentRenderer.translate(drawer.position.x, drawer.position.y);\n    }\n    cancelTranslate(drawer) {\n        drawer.p.currentRenderer.translate(-drawer.position.x, -drawer.position.y);\n    }\n    translateOnlyOffset(drawer) {\n        drawer.p.currentRenderer.translate(drawer.offsetPosition.x, drawer.offsetPosition.y);\n    }\n    cancelTranslateOnlyOffset(drawer) {\n        drawer.p.currentRenderer.translate(-drawer.offsetPosition.x, -drawer.offsetPosition.y);\n    }\n    translateWithOffset(drawer) {\n        drawer.p.currentRenderer.translate(drawer.position.x + drawer.offsetPosition.x, drawer.position.y + drawer.offsetPosition.y);\n    }\n    cancelTranslateWithOffset(drawer) {\n        drawer.p.currentRenderer.translate(-(drawer.position.x + drawer.offsetPosition.x), -(drawer.position.y + drawer.offsetPosition.y));\n    }\n    rotate(drawer) {\n        drawer.p.currentRenderer.rotate(drawer.rotation.value);\n    }\n    cancelRotate(drawer) {\n        drawer.p.currentRenderer.rotate(-drawer.rotation.value);\n    }\n    scale(drawer) {\n        if (drawer.scaleFactor.value === 1)\n            return;\n        drawer.scaleFactor.applyScale();\n    }\n    cancelScale(drawer) {\n        if (drawer.scaleFactor.value === 1)\n            return;\n        drawer.scaleFactor.cancel();\n    }\n    color(drawer) {\n        drawer.shapeColor.applyColor();\n    }\n    alphaColor(drawer) {\n        drawer.shapeColor.applyColor(drawer.alphaChannel.value);\n    }\n    applyStrokeWeight(drawer) {\n        drawer.p.currentRenderer.strokeWeight(drawer.strokeWeight.value);\n    }\n    applyTextSize(drawer) {\n        drawer.p.currentRenderer.textSize(drawer.textSize.value);\n    }\n}\n\n/**\n * (To be filled)\n */\nclass ShapeType {\n    /**\n     * @param drawShape\n     */\n    constructor(drawShape) {\n        this.drawShape = drawShape;\n    }\n}\nconst COS60 = 1 / 2;\nconst SIN60 = Math.sqrt(3) / 2;\n\n/**\n * Set of shape types.\n */\nconst ShapeTypes = {\n    CIRCLE: new ShapeType((renderer, size) => { renderer.ellipse(0, 0, size, size); }),\n    SQUARE: new ShapeType((renderer, size) => { renderer.rect(0, 0, size, size); }),\n    REGULAR_TRIANGLE: new ShapeType((renderer, size) => {\n        const radius = 0.5 * size;\n        renderer.triangle(radius, 0, -COS60 * radius, -SIN60 * radius, -COS60 * radius, +SIN60 * radius);\n    }),\n    REGULAR_TRIANGLE_UPWARD: new ShapeType((renderer, size) => {\n        const radius = 0.5 * size;\n        renderer.triangle(0, radius, -SIN60 * radius, -COS60 * radius, +SIN60 * radius, -COS60 * radius);\n    }),\n};\n\n/**\n * (To be filled)\n */\nclass ScalableShape {\n    /**\n     *\n     * @param p5exInstance\n     * @param shapeType - type chosen from p5ex.ShapeTypes\n     * @param {number} baseShapeSize\n     * @param {NumberContainer} [scaleFactorRef]\n     */\n    constructor(p5exInstance, shapeType, baseShapeSize, scaleFactorRef = new NumberContainer(1)) {\n        this.p = p5exInstance;\n        this.shapeType = shapeType;\n        this.baseShapeSize = baseShapeSize;\n        this.scaleFactorRef = scaleFactorRef;\n    }\n    /**\n     * Draws the shape.\n     */\n    draw() {\n        this.shapeType.drawShape(this.p, this.scaleFactorRef.value * this.baseShapeSize);\n    }\n}\n\n/**\n * (To be filled)\n */\nclass LineSegment {\n    constructor(p, x1, y1, x2, y2) {\n        this.p = p;\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n    }\n    draw() {\n        this.p.currentRenderer.line(this.x1, this.y1, this.x2, this.y2);\n    }\n}\n\n/**\n * (To be filled)\n */\nclass CircularArc {\n    constructor(p, centerPosition, diameter, startAngle, endAngle, isClockwise, startRatio, endRatio) {\n        this.p = p;\n        this.centerPosition = centerPosition;\n        this.diameter = diameter;\n        this.startAngle = startAngle;\n        this.endAngle = endAngle;\n        this.startRatio = startRatio;\n        this.endRatio = endRatio;\n        this.isClockwise = isClockwise;\n    }\n    get isClockwise() { return this._isClockwise; }\n    set isClockwise(flag) {\n        this._isClockwise = flag;\n        this.validate = flag ? validateClockwise : validateAntiClockwise;\n        this.drawTrimmedArc = flag ? drawClockwise : drawAntiClockwise;\n    }\n    draw() {\n        this.validate(this);\n        const angleDifference = this.endAngle.value - this.startAngle.value;\n        const start = this.startAngle.value +\n            this.startRatio.value * angleDifference;\n        const end = this.startAngle.value +\n            this.endRatio.value * angleDifference;\n        this.drawTrimmedArc(this.p, this.centerPosition, this.diameter.value, start, end);\n    }\n}\nfunction validateClockwise(arc) {\n    if (arc.startAngle.value > arc.endAngle.value)\n        arc.endAngle.value += arc.p.TWO_PI;\n}\nfunction validateAntiClockwise(arc) {\n    if (arc.startAngle.value < arc.endAngle.value)\n        arc.endAngle.value -= arc.p.TWO_PI;\n}\nfunction drawClockwise(p, centerPosition, diameter, trimmedStartAngle, trimmedEndAngle) {\n    p.currentRenderer.arc(centerPosition.x, centerPosition.y, diameter, diameter, trimmedStartAngle, trimmedEndAngle);\n}\nfunction drawAntiClockwise(p, centerPosition, diameter, trimmedStartAngle, trimmedEndAngle) {\n    p.currentRenderer.arc(centerPosition.x, centerPosition.y, diameter, diameter, trimmedEndAngle, trimmedStartAngle);\n}\n\n// temporal vectors for use in QuadraticBezierCurve.\nconst tmpMidPoint1 = dummyP5.createVector();\nconst tmpMidPoint2 = dummyP5.createVector();\n/**\n * Trimmable quadratic bezier curve.\n */\nclass QuadraticBezierCurve {\n    /**\n     *\n     * @param p\n     * @param startPoint\n     * @param controlPoint\n     * @param endPoint\n     * @param resolution\n     * @param startRatioRef\n     * @param endRatioRef\n     */\n    constructor(p, startPoint, controlPoint, endPoint, resolution, startRatioRef, endRatioRef) {\n\n        this.pointList = new Array(resolution + 1);\n        this.resolution = resolution;\n        this.startRatio = startRatioRef;\n        this.endRatio = endRatioRef;\n        this.p = p;\n        for (let i = 0; i <= resolution; i += 1) {\n            const ratio2 = i / resolution;\n            const ratio1 = 1 - ratio2;\n            tmpMidPoint1.set(ratio1 * startPoint.x + ratio2 * controlPoint.x, ratio1 * startPoint.y + ratio2 * controlPoint.y);\n            tmpMidPoint2.set(ratio1 * controlPoint.x + ratio2 * endPoint.x, ratio1 * controlPoint.y + ratio2 * endPoint.y);\n            this.pointList[i] = p.createVector(ratio1 * tmpMidPoint1.x + ratio2 * tmpMidPoint2.x, ratio1 * tmpMidPoint1.y + ratio2 * tmpMidPoint2.y);\n        }\n    }\n    /**\n     * Returns true if the provided control point candidate is valid.\n     * @param controlPoint - The control point candidate to be checked.\n     * @param startPoint - The start point of the bezier curve.\n     * @param endPoint - The start point of the bezier curve.\n     * @param minDistance - Minimum distance between the control point and the start/end point.\n     * @param minAngle - Minimum angle of the control point.\n     * @param maxAngle - Maximum angle of the control point.\n     * @static\n     */\n    static checkControlPoint(controlPoint, startPoint, endPoint, minDistance, minAngle, maxAngle) {\n        const minDistanceSquared = minDistance * minDistance;\n        if (distSq(controlPoint, startPoint) < minDistanceSquared)\n            return false;\n        if (distSq(controlPoint, endPoint) < minDistanceSquared)\n            return false;\n        const angle = Math.abs(angleDifference(getDirectionAngle(controlPoint, startPoint), getDirectionAngle(controlPoint, endPoint)));\n        if (angle < minAngle)\n            return false;\n        if (angle > maxAngle)\n            return false;\n        return true;\n    }\n    draw() {\n        const startIndex = Math.floor(this.startRatio.value * this.resolution);\n        const endIndex = Math.floor(this.endRatio.value * this.resolution);\n        const indexRemainder = this.endRatio.value * this.resolution - endIndex;\n        const renderer = this.p.currentRenderer;\n        const points = this.pointList;\n        renderer.beginShape();\n        for (let i = startIndex; i <= endIndex; i += 1) {\n            renderer.vertex(points[i].x, points[i].y);\n        }\n        if (indexRemainder > 0) {\n            renderer.vertex(points[endIndex].x + indexRemainder * (points[endIndex + 1].x - points[endIndex].x), points[endIndex].y + indexRemainder * (points[endIndex + 1].y - points[endIndex].y));\n        }\n        renderer.endShape();\n    }\n}\n\n/**\n * Draws a sine wave.\n * @param p\n * @param drawingLength\n * @param peakToPeakAmplitude\n * @param waveLength\n */\nfunction drawSineWave(p, drawingLength, peakToPeakAmplitude, waveLength) {\n    const renderer = p.currentRenderer;\n    const peakAmplitude = 0.5 * peakToPeakAmplitude;\n    let reachedEnd = false;\n    renderer.beginShape();\n    for (let x = 0; x <= drawingLength; x += 1) {\n        if (x > drawingLength)\n            reachedEnd = true;\n        renderer.vertex(reachedEnd ? drawingLength : x, -peakAmplitude * Math.sin(p.TWO_PI * x / waveLength));\n        if (reachedEnd)\n            break;\n    }\n    renderer.endShape();\n}\n/**\n * Set color to the specified pixel.\n * Should be used in conjunction with loadPixels() and updatePixels().\n * @param renderer - Instance of either p5 or p5.Graphics.\n * @param x - The x index of the pixel.\n * @param y - The y index of the pixel.\n * @param red - The red value (0 - 255).\n * @param green - The green value (0 - 255).\n * @param blue - The blue value (0 - 255).\n * @param pixelDensity - If not specified, renderer.pixelDensity() will be called.\n */\nfunction setPixel(renderer, x, y, red, green, blue, alpha, pixelDensity) {\n    const g = renderer;\n    const d = pixelDensity || g.pixelDensity();\n    for (let i = 0; i < d; i += 1) {\n        for (let j = 0; j < d; j += 1) {\n            const idx = 4 * ((y * d + j) * g.width * d + (x * d + i));\n            g.pixels[idx] = red;\n            g.pixels[idx + 1] = green;\n            g.pixels[idx + 2] = blue;\n            g.pixels[idx + 3] = alpha;\n        }\n    }\n}\n/**\n * Lerp color to the specified pixel. The alpha channel remains unchanged.\n * Should be used in conjunction with loadPixels() and updatePixels().\n * @param renderer - Instance of either p5 or p5.Graphics.\n * @param x - The x index of the pixel.\n * @param y - The y index of the pixel.\n * @param red - The red value (0 - 255).\n * @param green - The green value (0 - 255).\n * @param blue - The blue value (0 - 255).\n * @param pixelDensity - If not specified, renderer.pixelDensity() will be called.\n * @param lerpRatio - The lerp ratio (0 - 1). If 1, the color will be replaced.\n */\nfunction lerpPixel(renderer, x, y, red, green, blue, pixelDensity, lerpRatio = 1) {\n    const g = renderer;\n    const d = pixelDensity || g.pixelDensity();\n    for (let i = 0; i < d; i += 1) {\n        for (let j = 0; j < d; j += 1) {\n            const idx = 4 * ((y * d + j) * g.width * d + (x * d + i));\n            g.pixels[idx] = lerp(g.pixels[idx], red, lerpRatio);\n            g.pixels[idx + 1] = lerp(g.pixels[idx + 1], green, lerpRatio);\n            g.pixels[idx + 2] = lerp(g.pixels[idx + 2], blue, lerpRatio);\n            // g.pixels[idx + 3] = 255;\n        }\n    }\n}\n/**\n * Fill the canvas or graphics (according to p.currentRenderer) with gradation.\n * @param p\n * @param backgroundColor\n * @param fromColor\n * @param toColor\n * @param lerpRatioExponent\n */\nfunction gradationBackground(p, backgroundColor, fromColor, toColor, lerpRatioExponent = 1) {\n    const g = p.currentRenderer;\n    g.background(backgroundColor);\n    g.strokeWeight(2);\n    for (let y = 0; y < g.width; y += 1) {\n        const lerpRatio = Math.pow(y / (g.height - 1), lerpRatioExponent);\n        g.stroke(p.lerpColor(fromColor, toColor, lerpRatio));\n        g.line(0, y, g.width - 1, y);\n    }\n}\nfunction lerpPixelForRandomTexture(renderer, x, y, red, green, blue, alpha) {\n    lerpPixel(renderer, x, y, red, green, blue, undefined, alpha / 255);\n}\n/**\n * Sets the specified color (default: black) to each pixel with a random alpha value.\n * @param renderer - Instance of either p5 or p5.Graphics.\n * @param {number} maxAlpha - The max value of alpha channel (1 - 255).\n * @param {boolean} [blend] - Set true for blending, false for replacing.\n * @param {number} [red]\n * @param {number} [green]\n * @param {number} [blue]\n */\nfunction applyRandomTexture(renderer, maxAlpha, blend = true, red = 0, green = 0, blue = 0) {\n    const g = renderer;\n    const width = g.width;\n    const height = g.height;\n    const operatePixel = blend ? lerpPixelForRandomTexture : setPixel;\n    g.loadPixels();\n    for (let y = 0; y < height; y += 1) {\n        for (let x = 0; x < width; x += 1) {\n            operatePixel(renderer, x, y, red, green, blue, Math.random() * maxAlpha);\n        }\n    }\n    g.updatePixels();\n    return g;\n}\n\n/**\n * Font class.\n */\nclass FontUnit {\n    /**\n     *\n     * @param p - p5ex instance.\n     * @param {string} name - The font name.\n     * @param {string} [filePath] - The file path of the font.\n     *     Not required if the font is already loaded (e.g. as a web font).\n     */\n    constructor(p, name, filePath) {\n        this.p = p;\n        this.filePath = filePath || null;\n        this.textFontArgument = name;\n    }\n    /**\n     * Loads the font file if the file path has been specified.\n     */\n    loadFile() {\n        if (this.filePath)\n            this.textFontArgument = this.p.loadFont(this.filePath);\n    }\n    /**\n     * Applies the font to the current renderer.\n     */\n    applyFont() {\n        this.p.currentRenderer.textFont(this.textFontArgument);\n    }\n}\n/**\n * Manager class of FontUnit.\n */\nclass FontManager {\n    /**\n     *\n     * @param p - p5ex instance.\n     */\n    constructor(p) {\n        this.p = p;\n        this.fontMap = new Map();\n    }\n    /**\n     * Registers a new font.\n     * @param p\n     * @param name\n     * @param filePath\n     * @chainable\n     */\n    register(name, filePath) {\n        this.fontMap.set(name, new FontUnit(this.p, name, filePath));\n        return this;\n    }\n    /**\n     * Calls loadFile() for each registered font. Should be called in preload().\n     */\n    loadAll() {\n        for (const font of this.fontMap.values()) {\n            font.loadFile();\n        }\n    }\n    /**\n     * Applies the specified font to the current renderer.\n     * @param {string} name - The font name.\n     */\n    applyFont(name) {\n        const font = this.fontMap.get(name);\n        if (font)\n            font.applyFont();\n    }\n}\n\n/**\n * (To be filled)\n */\nclass AngleQuantity {\n    /**\n     * Null object of AngleQuantity.\n     * @static\n     */\n    static get NULL() { return NULL$1; }\n    /**\n     *\n     * @param angle\n     * @param angleVelocity\n     */\n    constructor(angle = 0, angleVelocity = 0) {\n        this.angleReference = new NumberContainer(angle);\n        this.angleVelocityReference = new NumberContainer(angleVelocity);\n    }\n    /**\n     * Current angle value.\n     */\n    get angle() { return this.angleReference.value; }\n    set angle(v) { this.angleReference.value = v; }\n    /**\n     * Current anglular velocity value.\n     */\n    get angleVelocity() { return this.angleVelocityReference.value; }\n    set angleVelocity(v) { this.angleVelocityReference.value = v; }\n    /**\n     * Updates the angle.\n     */\n    step() {\n        this.angle += this.angleVelocity;\n    }\n}\nclass NullAngleQuantity extends AngleQuantity {\n    get angle() { return 0; }\n    set angle(v) { }\n    get angleVelocity() { return 0; }\n    set angleVelocity(v) { }\n    step() { }\n}\nconst NULL$1 = new NullAngleQuantity();\n\n/**\n * (To be filled)\n */\nclass KinematicQuantity {\n    constructor() {\n        this.position = new p5.Vector();\n        this.velocity = new p5.Vector();\n    }\n    /**\n     * Updates the position.\n     */\n    step() {\n        this.position.add(this.velocity);\n    }\n    /**\n     * Returns the current speed.\n     */\n    getSpeed() {\n        return this.velocity.mag();\n    }\n    /**\n     * Returns the current direction angle.\n     */\n    getDirection() {\n        return this.velocity.heading();\n    }\n    /**\n     * Adds the given value to the current speed.\n     * @param speedChange\n     */\n    addSpeed(speedChange) {\n        this.velocity.setMag(Math.max(0, this.velocity.mag() + speedChange));\n    }\n}\n\nconst temporalVector = dummyP5.createVector();\n/**\n * (To be filled)\n */\nclass PhysicsBody {\n    constructor() {\n        this.kinematicQuantity = new KinematicQuantity();\n        this.position = this.kinematicQuantity.position;\n        this.velocity = this.kinematicQuantity.velocity;\n        this.mass = 1;\n        this.collisionRadius = 0;\n        this.hasFriction = false;\n        this.decelerationFactor = 1;\n    }\n    /**\n     * X position.\n     */\n    get x() {\n        return this.position.x;\n    }\n    /**\n     * Y position.\n     */\n    get y() {\n        return this.position.y;\n    }\n    /**\n     * Z position.\n     */\n    get z() {\n        return this.position.z;\n    }\n    /**\n     * X velocity.\n     */\n    get vx() {\n        return this.velocity.x;\n    }\n    /**\n     * Y velocity.\n     */\n    get vy() {\n        return this.velocity.y;\n    }\n    /**\n     * Z velocity.\n     */\n    get vz() {\n        return this.velocity.z;\n    }\n    /**\n     * Returns the current speed.\n     */\n    getSpeed() {\n        return this.kinematicQuantity.getSpeed();\n    }\n    /**\n     * Returns the current direction angle.\n     */\n    getDirection() {\n        return this.kinematicQuantity.getDirection();\n    }\n    /**\n     * Sets the friction of the body.\n     * @param constant\n     */\n    setFriction(constant) {\n        if (constant === 0) {\n            this.hasFriction = false;\n            return;\n        }\n        this.hasFriction = true;\n        this.decelerationFactor = 1 - constant;\n    }\n    /**\n     * Constrains the current speed. Should be called every time if needed.\n     * @param maxSpeed\n     */\n    constrainSpeed(maxSpeed) {\n        if (this.velocity.magSq() > maxSpeed * maxSpeed)\n            this.velocity.setMag(maxSpeed);\n    }\n    /**\n     * Updates the body.\n     */\n    step() {\n        this.kinematicQuantity.step();\n        if (this.hasFriction) {\n            this.kinematicQuantity.velocity.mult(this.decelerationFactor);\n        }\n    }\n    /**\n     * Accelerates the body.\n     * @param x\n     * @param y\n     * @param z\n     */\n    accelerate(x, y, z) {\n        this.kinematicQuantity.velocity.add(x, y, z);\n    }\n    /**\n     * Apply the provided force to the body.\n     * @param force\n     */\n    applyForce(force) {\n        this.accelerate(force.x / this.mass, force.y / this.mass, force.z / this.mass);\n    }\n    /**\n     * Add the provided value to the speed of the body.\n     * @param speedChange\n     */\n    addSpeed(speedChange) {\n        this.kinematicQuantity.addSpeed(speedChange);\n    }\n    /**\n     * Returns true if the body collides the provided body.\n     * @param other\n     */\n    collides(other) {\n        return (distSq(this.position, other.position) <\n            this.collisionRadius * this.collisionRadius + other.collisionRadius * other.collisionRadius);\n    }\n    /**\n     * (To be filled)\n     * @param normalUnitVector\n     * @param restitution\n     */\n    bounce(normalUnitVector, restitution = 1) {\n        this.velocity.add(p5.Vector.mult(normalUnitVector, (1 + restitution) * p5.Vector.dot(this.velocity, p5.Vector.mult(normalUnitVector, -1))));\n    }\n    /**\n     * Applies attraction force to both this and the target body.\n     * @param {PhysicsBody} other - the other body to interact with\n     * @param {number} magnitudeFactor - the factor of magnitude other than the distance\n     * @param {number} minMag - the minimum magnitude\n     * @param {number} maxMag - the maximum magnitude\n     * @param {number} cutoffMag - does not apply force if magnitude is smaller than this\n     */\n    attractEachOther(other, magnitudeFactor, minMag = 0, maxMag, cutoffMag) {\n        const force = this.calculateAttractionForce(other.position, magnitudeFactor, minMag, maxMag, cutoffMag);\n        if (!force)\n            return;\n        this.applyForce(force);\n        force.mult(-1);\n        other.applyForce(force);\n    }\n    /**\n     * Applies attraction force to this body.\n     * @param {p5.Vector} targetPosition - the target position\n     * @param {number} magnitudeFactor - the factor of magnitude other than the distance\n     * @param {number} minMag - the minimum magnitude\n     * @param {number} maxMag - the maximum magnitude\n     * @param {number} cutoffMag - does not apply force if magnitude is smaller than this\n     */\n    attractToPoint(targetPosition, magnitudeFactor, minMag = 0, maxMag, cutoffMag) {\n        const force = this.calculateAttractionForce(targetPosition, magnitudeFactor, minMag, maxMag, cutoffMag);\n        if (!force)\n            return;\n        this.applyForce(force);\n    }\n    calculateAttractionForce(targetPosition, magnitudeFactor, minMag = 0, maxMag, cutoffMag) {\n        const tmpVec = temporalVector;\n        p5.Vector.sub(targetPosition, this.position, tmpVec); // set relative position\n        const distanceSquared = tmpVec.magSq();\n        let magnitude = Math.abs(magnitudeFactor) / distanceSquared;\n        if (cutoffMag && magnitude < cutoffMag)\n            return null;\n        if (maxMag)\n            magnitude = Math.min(Math.max(magnitude, minMag), maxMag);\n        else\n            magnitude = Math.max(magnitude, minMag);\n        tmpVec.setMag(magnitude); // set force\n        if (magnitudeFactor < 0)\n            tmpVec.mult(-1);\n        return tmpVec;\n    }\n}\n\n/**\n * Returns the 2D force vector which is to be applied to the load.\n * @param loadDirectionAngle - the direction angle from the fulcrum to the load\n * @param loadDistance - the distance between the fulcrum and the load\n * @param effortDistance - the distance between the fulcrum and the effort\n * @param effortForceMagnitude - the effort force magnitude\n * @param rotateClockwise - true if the load is to be rotated clockwise, otherwise false\n * @param target - the vector to receive the result. Will be newly created if not specified\n */\nfunction calculateLeverageForce(loadDirectionAngle, loadDistance, effortDistance, effortForceMagnitude, rotateClockwise, target) {\n    const force = target || dummyP5.createVector();\n    const forceDirectionAngle = loadDirectionAngle + (rotateClockwise ? -dummyP5.HALF_PI : dummyP5.HALF_PI);\n    force.set(Math.cos(forceDirectionAngle), Math.sin(forceDirectionAngle));\n    force.setMag(effortForceMagnitude * effortDistance / loadDistance); // load force\n    return force;\n}\n\n/**\n * (To be filled)\n */\nclass FrameCounter {\n    constructor() {\n        this.count = 0;\n    }\n    /**\n     * Resets the counter.\n     * @param count\n     */\n    resetCount(count = 0) {\n        this.count = count;\n        return this;\n    }\n    /**\n     * Increments the frame count.\n     */\n    step() {\n        this.count += 1;\n    }\n    /**\n     * Returns the mod.\n     * @param divisor\n     */\n    mod(divisor) {\n        return this.count % divisor;\n    }\n}\n\n/**\n * (To be filled)\n */\nclass TimedFrameCounter extends FrameCounter {\n    /**\n     * True if this counter is activated.\n     */\n    get isOn() { return this._isOn; }\n\n    /**\n     *\n     * @param durationFrameCount\n     * @param completeBehavior\n     */\n    constructor(durationFrameCount, completeBehavior = EMPTY_FUNCTION) {\n        super();\n        this._isOn = true;\n        this.completeBehavior = completeBehavior;\n        this.durationFrameCount = durationFrameCount;\n    }\n    /**\n     * Activate this counter.\n     * @param duration\n     * @chainable\n     */\n    on(duration) {\n        this._isOn = true;\n        if (duration)\n            this.durationFrameCount = duration;\n        return this;\n    }\n    /**\n     * Deactivate this counter.\n     * @chainable\n     */\n    off() {\n        this._isOn = false;\n        return this;\n    }\n    /**\n     * @override\n     */\n    step() {\n        if (!this._isOn)\n            return;\n        this.count += 1;\n        if (this.count > this.durationFrameCount) {\n            this.completeCycle();\n        }\n    }\n}\n\n/**\n * (To be filled)\n */\nclass LoopedFrameCounter extends TimedFrameCounter {\n    /**\n     *\n     * @param duration\n     * @param cycleCompleteBehavior\n     */\n    constructor(duration, cycleCompleteBehavior) {\n        super(duration, cycleCompleteBehavior);\n    }\n    /**\n     * @override\n     * @chainable\n     */\n    on(duration) {\n        super.on(duration);\n        return this;\n    }\n    /**\n     * @override\n     * @chainable\n     */\n    off() {\n        super.off();\n        return this;\n    }\n    /**\n     * @override\n     */\n    getProgressRatio() {\n        return this.count / this.durationFrameCount;\n    }\n    /**\n     * @override\n     */\n    completeCycle() {\n        this.completeBehavior();\n        this.count = 0;\n    }\n}\n\n/**\n * (To be filled)\n */\nclass NonLoopedFrameCounter extends TimedFrameCounter {\n    /**\n     * True if the given frame count duration has ellapsed already.\n     */\n    get isCompleted() { return this._isCompleted; }\n\n    /**\n     *\n     * @param durationFrameCount\n     * @param completeBehavior\n     */\n    constructor(durationFrameCount, completeBehavior) {\n        super(durationFrameCount, completeBehavior);\n        this._isCompleted = false;\n    }\n    /**\n     * @override\n     * @chainable\n     */\n    on(duration) {\n        super.on(duration);\n        return this;\n    }\n    /**\n     * @override\n     * @chainable\n     */\n    off() {\n        super.off();\n        return this;\n    }\n    /**\n     * @override\n     */\n    resetCount() {\n        super.resetCount();\n        this._isCompleted = false;\n        return this;\n    }\n    /**\n     * @override\n     */\n    getProgressRatio() {\n        return this._isCompleted ? 1 : this.count / this.durationFrameCount;\n    }\n    /**\n     * @override\n     */\n    completeCycle() {\n        this._isCompleted = true;\n        this._isOn = false;\n        this.completeBehavior();\n    }\n}\n\n/**\n * Holds a boolean value for each key which indicates if the key is currently down.\n */\nconst keyDown = new Map();\n/**\n * Begins to listen key events. Default behaviors for arrow keys will be prevented.\n */\nfunction listenKey() {\n    window.addEventListener('keydown', (event) => {\n        keyDown.set(event.key, true);\n        keyDown.set(event.code, true);\n        switch (event.key) {\n            case 'ArrowDown':\n            case 'ArrowUp':\n            case 'ArrowLeft':\n            case 'ArrowRight':\n                return false;\n            default:\n                return;\n        }\n    });\n    window.addEventListener('keyup', (event) => {\n        keyDown.set(event.key, false);\n        keyDown.set(event.code, false);\n        switch (event.key) {\n            case 'ArrowDown':\n            case 'ArrowUp':\n            case 'ArrowLeft':\n            case 'ArrowRight':\n                return false;\n            default:\n                return;\n        }\n    });\n}\n\n/**\n * Returns true if the mouse cursor is on the canvas.\n * @param p - p5ex instance.\n */\nfunction mouseOnCanvas(p) {\n    if (p.mouseX < 0)\n        return false;\n    if (p.mouseX > p.width)\n        return false;\n    if (p.mouseY < 0)\n        return false;\n    if (p.mouseY > p.height)\n        return false;\n    return true;\n}\n\n/**\n * Extension of p5 class.\n */\n\nclass p5exClass extends p5 {\n    /**\n     * Sets the current renderer object.\n     * @param renderer\n     */\n    setCurrentRenderer(renderer) {\n        this.currentRenderer = renderer;\n    }\n    /**\n      * The non-scaled width of the canvas.\n      */\n    get nonScaledWidth() {\n        return this.scalableCanvas.nonScaledWidth;\n    }\n    /**\n     * The non-scaled height of the canvas.\n     */\n    get nonScaledHeight() {\n        return this.scalableCanvas.nonScaledHeight;\n    }\n\n    /**\n     * The ideal frame rate which was set by setFrameRate().\n     */\n    get idealFrameRate() { return this._idealFrameRate; }\n    /**\n     * Anglular displacement in radians per frame which corresponds to 1 cycle per second.\n     * Set by setFrameRate().\n     */\n    get unitAngleSpeed() { return this._unitAngleSpeed; }\n    /**\n     * Positional displacement per frame which corresponds to 1 unit length per second.\n     * Set by setFrameRate().\n     */\n    get unitSpeed() { return this._unitSpeed; }\n    /**\n     * Change of speed per frame which corresponds to 1 unit speed per second.\n     * Set by setFrameRate().\n     */\n    get unitAccelerationMagnitude() { return this._unitAccelerationMagnitude; }\n    /**\n     * Constructor of class p5ex.\n     * @param sketch\n     * @param node\n     * @param sync\n     */\n    constructor(sketch, node, sync) {\n        super(sketch, typeof node === 'string' ? document.getElementById(node) || undefined : node, sync);\n        if (!node || typeof node === 'boolean') {\n            this.node = document.body;\n        }\n        else {\n            this.node = typeof node === 'string' ? document.getElementById(node) || document.body : node;\n        }\n        this.currentRenderer = this;\n        this.maxCanvasRegion = {\n            width: 0,\n            height: 0,\n            getShortSideLength() { return Math.min(this.width, this.height); },\n        };\n        this.updateMaxCanvasRegion();\n        this.setFrameRate();\n    }\n    /**\n     * Calls frameRate() and sets variables related to the frame rate.\n     * @param {number} [fps=60] - The ideal frame rate per second.\n     */\n    setFrameRate(fps = 60) {\n        this.frameRate(fps);\n        if (fps) {\n            this._idealFrameRate = fps;\n            this._unitAngleSpeed = 2 * Math.PI / this._idealFrameRate;\n            this._unitSpeed = 1 / this._idealFrameRate;\n            this._unitAccelerationMagnitude = this._unitSpeed / this._idealFrameRate;\n        }\n        return this;\n    }\n    /**\n     * Updates the value of the variable maxCanvasRegion.\n     */\n    updateMaxCanvasRegion() {\n        this.maxCanvasRegion.width = this.windowWidth;\n        this.maxCanvasRegion.height = this.windowHeight;\n        if (this.node === document.body)\n            return;\n        const containerRect = this.node.getBoundingClientRect();\n        this.maxCanvasRegion.width = containerRect.width;\n        this.maxCanvasRegion.height = containerRect.height;\n    }\n    /**\n     * Create an instance of ScalableCanvas. This includes calling of createCanvas().\n     * @param {ScalableCanvasType} type - Type chosen from p5ex.ScalableCanvasTypes.\n     * @param {ScalableCanvasParameters} [parameters] - Parameters for type CUSTOM.\n     * @param {string} [rendererType] - Either P2D or WEBGL.\n     */\n    createScalableCanvas(type, parameters, rendererType) {\n        this.scalableCanvasType = type;\n        this.scalableCanvas = new ScalableCanvas(this, this.createScalableCanvasParameter(type, parameters), this.node, rendererType);\n    }\n    /**\n     * Resizes the ScalableCanvas. Does not work on OpenProcessing.\n     * @param {ScalableCanvasType} [type] - Type chosen from p5ex.ScalableCanvasTypes.\n     *     If undefined, the last used type will be used again.\n     * @param {ScalableCanvasParameters} [parameters] - Parameters for type CUSTOM.\n     */\n    resizeScalableCanvas(type, parameters) {\n        this.scalableCanvas.resize(this.createScalableCanvasParameter(type || this.scalableCanvasType, parameters));\n    }\n    createScalableCanvasParameter(type, parameters) {\n        this.updateMaxCanvasRegion();\n        const maxShortSide = this.maxCanvasRegion.getShortSideLength();\n        switch (type) {\n            case ScalableCanvasTypes.SQUARE640x640:\n                return {\n                    scaledWidth: maxShortSide,\n                    scaledHeight: maxShortSide,\n                    nonScaledShortSideLength: 640,\n                };\n            case ScalableCanvasTypes.RECT640x480:\n                return {\n                    scaledWidth: maxShortSide,\n                    scaledHeight: 0.75 * maxShortSide,\n                    nonScaledShortSideLength: 480,\n                };\n            case ScalableCanvasTypes.FULL:\n                return {\n                    scaledWidth: this.maxCanvasRegion.width,\n                    scaledHeight: this.maxCanvasRegion.height,\n                    nonScaledShortSideLength: 640,\n                };\n            default:\n                return parameters || ScalableCanvas.DUMMY_PARAMETERS;\n        }\n    }\n}\n\nexport { p5exClass, loopArray, loopArrayBackwards, roundRobin, nestedLoopJoin, LoopableArray, EMPTY_FUNCTION, distSq, multiplyMatrixAndArray, angleDifference, getDirectionAngle, lerp, randomBetween, randomInt, randomIntBetween, getRandom, popRandom, randomSign, NumberContainer, WeightedRandomSelector, easeLinear, easeOutQuad, easeOutCubic, easeOutQuart, easeOutBack, getEasingFunction, dummyP5, Region, RectangleRegion, ScalableCanvas, ScalableCanvasTypes, ScreenEffect, ScreenShake, ScreenFlash, AlphaBackground, mouseIsInCanvas, TwoDimensionalArray, NaiveEdge, NaiveCell, NullCell, Grid, DrawableArray, SteppableArray, SpriteArray, CleanableArray, CleanableSpriteArray, ObjectPool, PoolableArray, ShapeColor, RandomShapeColor, setIlluminant, cielabColor, cielchColor, Illuminants, degamma, subtractColor, hsbColor, Drawer, DrawerBuilder, ShapeType, ShapeTypes, ScalableShape, LineSegment, CircularArc, QuadraticBezierCurve, drawSineWave, setPixel, lerpPixel, gradationBackground, applyRandomTexture, FontUnit, FontManager, ScaleFactor, AngleQuantity, KinematicQuantity, PhysicsBody, calculateLeverageForce, FrameCounter, LoopedFrameCounter, NonLoopedFrameCounter, keyDown, listenKey, mouseOnCanvas };\n","import * as p5ex from 'p5ex';\r\n\r\nconst SKETCH_NAME = 'CloudChamber';\r\n\r\nclass InvisibleBody extends p5ex.PhysicsBody {\r\n  shapeColor: p5ex.ShapeColor;\r\n\r\n  constructor(protected p: p5ex.p5exClass) {\r\n    super();\r\n    this.setColor();\r\n  }\r\n\r\n  setColor() {\r\n    this.shapeColor = new p5ex.ShapeColor(\r\n      this.p,\r\n      null,\r\n      this.p.color(p5ex.cielchColor(90, 100, this.p.TWO_PI * Math.random())),\r\n      true,\r\n    );\r\n  }\r\n}\r\n\r\nclass AutoInvisibleBody extends InvisibleBody {\r\n  constructor(p: p5ex.p5exClass) {\r\n    super(p);\r\n    this.position.set(p.random(0, p.nonScaledWidth), p.random(0, p.nonScaledHeight));\r\n    this.velocity.set(p5.Vector.fromAngle((0.5 + p5ex.randomInt(4)) * p.HALF_PI).mult(8));\r\n    this.collisionRadius = 20;\r\n  }\r\n\r\n  step() {\r\n    super.step();\r\n\r\n    if (this.x < 0 || this.x > this.p.nonScaledWidth) {\r\n      this.p.scalableCanvas.region.constrain(this.position);\r\n      this.velocity.set(-1 * this.vx, this.vy);\r\n    }\r\n    if (this.y < 0 || this.y > this.p.nonScaledHeight) {\r\n      this.p.scalableCanvas.region.constrain(this.position);\r\n      this.velocity.set(this.vx, -1 * this.vy);\r\n    }\r\n  }\r\n}\r\n\r\nclass ManualInvisibleBody extends InvisibleBody {\r\n  constructor(p: p5ex.p5exClass) {\r\n    super(p);\r\n    this.collisionRadius = 20;\r\n  }\r\n\r\n  step() {\r\n    const p = this.p;\r\n    this.position.set(p.mouseX / p.scalableCanvas.scaleFactor, p.mouseY / p.scalableCanvas.scaleFactor);\r\n  }\r\n}\r\n\r\nclass Indicator extends p5ex.PhysicsBody implements p5ex.Sprite {\r\n  static initialColor: p5ex.ShapeColor;\r\n\r\n  isOn: boolean = false;\r\n  life: number;\r\n  lifeChange: number;\r\n  shapeColor: p5ex.ShapeColor;\r\n\r\n  constructor(protected p: p5ex.p5exClass, x: number, y: number) {\r\n    super();\r\n    this.position.set(x, y);\r\n    this.collisionRadius = 5;\r\n    this.on(Indicator.initialColor);\r\n    this.life = 0.5;\r\n  }\r\n\r\n  step() {\r\n    if (!this.isOn) return;\r\n\r\n    this.life -= this.lifeChange;\r\n    if (this.life <= 0) this.isOn = false;\r\n  }\r\n\r\n  draw() {\r\n    if (!this.isOn) return;\r\n\r\n    const ratio = Math.sin(Math.PI * this.life);\r\n    this.shapeColor.applyColor(255 * ratio);\r\n    const diameter = 10 + 2 * ratio;\r\n    this.p.ellipse(this.position.x, this.position.y, diameter, diameter);\r\n  }\r\n\r\n  on(shapeColor: p5ex.ShapeColor) {\r\n    if (this.isOn) return;\r\n\r\n    this.isOn = true;\r\n    this.life = 1;\r\n    this.lifeChange = this.p.random(0.02, 0.03);\r\n    this.shapeColor = shapeColor;\r\n  }\r\n}\r\n\r\nconst sketch = (p: p5ex.p5exClass) => {\r\n  // ---- variables\r\n  let backgroundColor: p5.Color;\r\n  let invisibleBodies: p5ex.SteppableArray<p5ex.PhysicsBody>;\r\n  let indicators: p5ex.SpriteArray<Indicator>;\r\n  let mouseCursorColor: p5ex.ShapeColor;\r\n  const collisionCallback = (body: InvisibleBody, indicator: Indicator) => {\r\n    if (body.collides(indicator)) {\r\n      indicator.on(body.shapeColor);\r\n    }\r\n  };\r\n  const setColorCallback = (body: InvisibleBody) => {\r\n    body.setColor();\r\n  };\r\n\r\n  // ---- functions\r\n  function drawMouseCursor() {\r\n    mouseCursorColor.applyColor();\r\n    const diameter = 40 + 5 * Math.sin(p.TWO_PI * p.frameCount / 60);\r\n    p.ellipse(\r\n      p.mouseX / p.scalableCanvas.scaleFactor,\r\n      p.mouseY / p.scalableCanvas.scaleFactor,\r\n      diameter,\r\n      diameter,\r\n    );\r\n  }\r\n\r\n  // ---- Setup & Draw etc.\r\n  p.preload = () => {\r\n  };\r\n\r\n  p.setup = () => {\r\n    p.createScalableCanvas(\r\n      p5ex.ScalableCanvasTypes.SQUARE640x640,\r\n    );\r\n    p.stroke(0, 160);\r\n    p.noFill();\r\n\r\n    backgroundColor = p.color(252);\r\n\r\n    invisibleBodies = new p5ex.SteppableArray<InvisibleBody>();\r\n    invisibleBodies.push(new ManualInvisibleBody(p));\r\n\r\n    for (let i = 0; i < 3; i += 1) {\r\n      invisibleBodies.push(new AutoInvisibleBody(p));\r\n    }\r\n\r\n    indicators = new p5ex.SpriteArray<Indicator>(2 * 32 * 32);\r\n    Indicator.initialColor = new p5ex.ShapeColor(p, null, p.color(192), true);\r\n\r\n    const interval = 20;\r\n    for (let y = 1, yLen = p.nonScaledHeight / interval; y < yLen; y += 1) {\r\n      const evenRow = y % 2 === 0;\r\n      for (let x = 1, xLen = p.nonScaledWidth / interval; x < xLen; x += 1) {\r\n        indicators.push(new Indicator(p, (x + (evenRow ? 0 : 0.5)) * interval, y * interval));\r\n      }\r\n    }\r\n\r\n    mouseCursorColor = new p5ex.ShapeColor(p, null, p.color(0, 0, 128, 32));\r\n  };\r\n\r\n  p.draw = () => {\r\n    p.background(backgroundColor);\r\n    invisibleBodies.step();\r\n    indicators.step();\r\n    invisibleBodies.nestedLoopJoin(indicators, collisionCallback);\r\n\r\n    p.scalableCanvas.scale();\r\n    indicators.draw();\r\n    drawMouseCursor();\r\n    p.scalableCanvas.cancelScale();\r\n  };\r\n\r\n  p.windowResized = () => {\r\n  };\r\n\r\n  p.mousePressed = () => {\r\n    // if (!p5ex.mouseIsInCanvas(p)) return;\r\n    // p.noLoop();\r\n\r\n    invisibleBodies.loop(setColorCallback);\r\n  };\r\n\r\n  p.keyTyped = () => {\r\n    if (p.keyCode === (p as any).ENTER) p.noLoop();\r\n  };\r\n};\r\n\r\nnew p5ex.p5exClass(sketch, SKETCH_NAME);\r\n"],"names":["p5ex.PhysicsBody","p5ex.ShapeColor","p5ex.cielchColor","p5ex.randomInt","p5ex.ScalableCanvasTypes","p5ex.SteppableArray","p5ex.SpriteArray","p5ex.p5exClass"],"mappings":"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"}